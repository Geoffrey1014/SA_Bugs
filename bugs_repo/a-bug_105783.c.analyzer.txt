GNU C17 (GCC) version 13.0.0 20221104 (experimental) (x86_64-pc-linux-gnu)
	compiled by GNU C version 13.0.0 20221104 (experimental), GMP version 6.2.1, MPFR version 4.1.0, MPC version 1.2.1, isl version isl-0.24-GMP

entering: void ana::run_checkers()
 entering: void ana::impl_run_checkers(logger*)
  BITS_BIG_ENDIAN: 0
  BYTES_BIG_ENDIAN: 0
  WORDS_BIG_ENDIAN: 0
  entering: supergraph
   SN: 0...5: function 'main'
   SN: 6...11: function 'ss_out'
   SN: 12...15: function 'ss_init'
   SN: 16...18: function '__analyzer_eval'
  exiting: supergraph
  entering: state_purge_map
   function: main
   entering: state_purge_per_ssa_name
    SSA name: '_1' within 'main'
    def stmt: _1 = ss.counting;
    used by stmt: _2 = (int) _1;
    entering: add_to_worklist
     point: 'before (SN: 2 stmt: 1):  _2 = (int) _1;' for worklist for '_1'
     not seen; adding to worklist for '_1'
    exiting: add_to_worklist
    not last stmt in BB
    entering: processing worklist
     entering: process_point
      considering point: 'before (SN: 2 stmt: 1):  _2 = (int) _1;' for '_1'
      entering: add_to_worklist
       point: 'before (SN: 2 stmt: 0):  _1 = ss.counting;' for worklist for '_1'
       not seen; adding to worklist for '_1'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'before (SN: 2 stmt: 0):  _1 = ss.counting;' for '_1'
      def stmt; terminating
     exiting: process_point
    exiting: processing worklist
    '_1' in 'main' is needed to process:
      point: before (SN: 2 stmt: 0):  _1 = ss.counting;
      point: before (SN: 2 stmt: 1):  _2 = (int) _1;
   exiting: state_purge_per_ssa_name
   entering: state_purge_per_ssa_name
    SSA name: '_2' within 'main'
    def stmt: _2 = (int) _1;
    used by stmt: __analyzer_describe (0, _2);
    entering: add_to_worklist
     point: 'before (SN: 2 stmt: 2):  __analyzer_describe (0, _2);' for worklist for '_2'
     not seen; adding to worklist for '_2'
    exiting: add_to_worklist
    not last stmt in BB
    entering: processing worklist
     entering: process_point
      considering point: 'before (SN: 2 stmt: 2):  __analyzer_describe (0, _2);' for '_2'
      entering: add_to_worklist
       point: 'before (SN: 2 stmt: 1):  _2 = (int) _1;' for worklist for '_2'
       not seen; adding to worklist for '_2'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'before (SN: 2 stmt: 1):  _2 = (int) _1;' for '_2'
      def stmt; terminating
     exiting: process_point
    exiting: processing worklist
    '_2' in 'main' is needed to process:
      point: before (SN: 2 stmt: 1):  _2 = (int) _1;
      point: before (SN: 2 stmt: 2):  __analyzer_describe (0, _2);
   exiting: state_purge_per_ssa_name
   entering: state_purge_per_ssa_name
    SSA name: '_8' within 'main'
    def stmt: _8 = 0;
    used by stmt: return _8;
    entering: add_to_worklist
     point: 'before (SN: 4 stmt: 1):  return _8;' for worklist for '_8'
     not seen; adding to worklist for '_8'
    exiting: add_to_worklist
    last stmt in BB
    entering: add_to_worklist
     point: 'after SN: 4' for worklist for '_8'
     not seen; adding to worklist for '_8'
    exiting: add_to_worklist
    entering: processing worklist
     entering: process_point
      considering point: 'after SN: 4' for '_8'
      entering: add_to_worklist
       point: 'before (SN: 4 stmt: 1):  return _8;' for worklist for '_8'
       already seen for '_8'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'before (SN: 4 stmt: 1):  return _8;' for '_8'
      entering: add_to_worklist
       point: 'before (SN: 4 stmt: 0):  <L0>:' for worklist for '_8'
       not seen; adding to worklist for '_8'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'before (SN: 4 stmt: 0):  <L0>:' for '_8'
      entering: add_to_worklist
       point: 'before SN: 4 (from SN: 3 (bb: 2)) ' for worklist for '_8'
       not seen; adding to worklist for '_8'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'before SN: 4 (from SN: 3 (bb: 2)) ' for '_8'
      entering: add_to_worklist
       point: 'after SN: 3' for worklist for '_8'
       not seen; adding to worklist for '_8'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'after SN: 3' for '_8'
      entering: add_to_worklist
       point: 'before (SN: 3 stmt: 1):  _8 = 0;' for worklist for '_8'
       not seen; adding to worklist for '_8'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'before (SN: 3 stmt: 1):  _8 = 0;' for '_8'
      def stmt; terminating
     exiting: process_point
    exiting: processing worklist
    '_8' in 'main' is needed to process:
      point: before (SN: 3 stmt: 1):  _8 = 0;
      point: after SN: 3
      point: before SN: 4 (from SN: 3 (bb: 2)) 
      point: before (SN: 4 stmt: 0):  <L0>:
      point: before (SN: 4 stmt: 1):  return _8;
      point: after SN: 4
   exiting: state_purge_per_ssa_name
   function: ss_out
   entering: state_purge_per_ssa_name
    SSA name: '_1' within 'ss_out'
    def stmt: _1 = t_13(D)->counting;
    used by stmt: _2 = (int) _1;
    entering: add_to_worklist
     point: 'before (SN: 7 stmt: 1):  _2 = (int) _1;' for worklist for '_1'
     not seen; adding to worklist for '_1'
    exiting: add_to_worklist
    not last stmt in BB
    entering: processing worklist
     entering: process_point
      considering point: 'before (SN: 7 stmt: 1):  _2 = (int) _1;' for '_1'
      entering: add_to_worklist
       point: 'before (SN: 7 stmt: 0):  _1 = t_13(D)->counting;' for worklist for '_1'
       not seen; adding to worklist for '_1'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'before (SN: 7 stmt: 0):  _1 = t_13(D)->counting;' for '_1'
      def stmt; terminating
     exiting: process_point
    exiting: processing worklist
    '_1' in 'ss_out' is needed to process:
      point: before (SN: 7 stmt: 0):  _1 = t_13(D)->counting;
      point: before (SN: 7 stmt: 1):  _2 = (int) _1;
   exiting: state_purge_per_ssa_name
   entering: state_purge_per_ssa_name
    SSA name: '_2' within 'ss_out'
    def stmt: _2 = (int) _1;
    used by stmt: __analyzer_describe (0, _2);
    entering: add_to_worklist
     point: 'before (SN: 7 stmt: 2):  __analyzer_describe (0, _2);' for worklist for '_2'
     not seen; adding to worklist for '_2'
    exiting: add_to_worklist
    not last stmt in BB
    entering: processing worklist
     entering: process_point
      considering point: 'before (SN: 7 stmt: 2):  __analyzer_describe (0, _2);' for '_2'
      entering: add_to_worklist
       point: 'before (SN: 7 stmt: 1):  _2 = (int) _1;' for worklist for '_2'
       not seen; adding to worklist for '_2'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'before (SN: 7 stmt: 1):  _2 = (int) _1;' for '_2'
      def stmt; terminating
     exiting: process_point
    exiting: processing worklist
    '_2' in 'ss_out' is needed to process:
      point: before (SN: 7 stmt: 1):  _2 = (int) _1;
      point: before (SN: 7 stmt: 2):  __analyzer_describe (0, _2);
   exiting: state_purge_per_ssa_name
   entering: state_purge_per_ssa_name
    SSA name: '_3' within 'ss_out'
    def stmt: _3 = t_13(D)->counting;
    used by stmt: _4 = ~_3;
    entering: add_to_worklist
     point: 'before (SN: 7 stmt: 4):  _4 = ~_3;' for worklist for '_3'
     not seen; adding to worklist for '_3'
    exiting: add_to_worklist
    not last stmt in BB
    entering: processing worklist
     entering: process_point
      considering point: 'before (SN: 7 stmt: 4):  _4 = ~_3;' for '_3'
      entering: add_to_worklist
       point: 'before (SN: 7 stmt: 3):  _3 = t_13(D)->counting;' for worklist for '_3'
       not seen; adding to worklist for '_3'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'before (SN: 7 stmt: 3):  _3 = t_13(D)->counting;' for '_3'
      def stmt; terminating
     exiting: process_point
    exiting: processing worklist
    '_3' in 'ss_out' is needed to process:
      point: before (SN: 7 stmt: 3):  _3 = t_13(D)->counting;
      point: before (SN: 7 stmt: 4):  _4 = ~_3;
   exiting: state_purge_per_ssa_name
   entering: state_purge_per_ssa_name
    SSA name: '_4' within 'ss_out'
    def stmt: _4 = ~_3;
    used by stmt: _5 = (int) _4;
    entering: add_to_worklist
     point: 'before (SN: 7 stmt: 5):  _5 = (int) _4;' for worklist for '_4'
     not seen; adding to worklist for '_4'
    exiting: add_to_worklist
    not last stmt in BB
    entering: processing worklist
     entering: process_point
      considering point: 'before (SN: 7 stmt: 5):  _5 = (int) _4;' for '_4'
      entering: add_to_worklist
       point: 'before (SN: 7 stmt: 4):  _4 = ~_3;' for worklist for '_4'
       not seen; adding to worklist for '_4'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'before (SN: 7 stmt: 4):  _4 = ~_3;' for '_4'
      def stmt; terminating
     exiting: process_point
    exiting: processing worklist
    '_4' in 'ss_out' is needed to process:
      point: before (SN: 7 stmt: 4):  _4 = ~_3;
      point: before (SN: 7 stmt: 5):  _5 = (int) _4;
   exiting: state_purge_per_ssa_name
   entering: state_purge_per_ssa_name
    SSA name: '_5' within 'ss_out'
    def stmt: _5 = (int) _4;
    used by stmt: __analyzer_eval (_5);
    entering: add_to_worklist
     point: 'before (SN: 7 stmt: 6):  __analyzer_eval (_5);' for worklist for '_5'
     not seen; adding to worklist for '_5'
    exiting: add_to_worklist
    last stmt in BB
    entering: add_to_worklist
     point: 'after SN: 7' for worklist for '_5'
     not seen; adding to worklist for '_5'
    exiting: add_to_worklist
    entering: processing worklist
     entering: process_point
      considering point: 'after SN: 7' for '_5'
      entering: add_to_worklist
       point: 'before (SN: 7 stmt: 6):  __analyzer_eval (_5);' for worklist for '_5'
       already seen for '_5'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'before (SN: 7 stmt: 6):  __analyzer_eval (_5);' for '_5'
      entering: add_to_worklist
       point: 'before (SN: 7 stmt: 5):  _5 = (int) _4;' for worklist for '_5'
       not seen; adding to worklist for '_5'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'before (SN: 7 stmt: 5):  _5 = (int) _4;' for '_5'
      def stmt; terminating
     exiting: process_point
    exiting: processing worklist
    '_5' in 'ss_out' is needed to process:
      point: before (SN: 7 stmt: 5):  _5 = (int) _4;
      point: before (SN: 7 stmt: 6):  __analyzer_eval (_5);
      point: after SN: 7
   exiting: state_purge_per_ssa_name
   entering: state_purge_per_ssa_name
    SSA name: '_6' within 'ss_out'
    def stmt: _6 = t_13(D)->counting;
    used by stmt: _7 = ~_6;
    entering: add_to_worklist
     point: 'before (SN: 8 stmt: 1):  _7 = ~_6;' for worklist for '_6'
     not seen; adding to worklist for '_6'
    exiting: add_to_worklist
    not last stmt in BB
    entering: processing worklist
     entering: process_point
      considering point: 'before (SN: 8 stmt: 1):  _7 = ~_6;' for '_6'
      entering: add_to_worklist
       point: 'before (SN: 8 stmt: 0):  _6 = t_13(D)->counting;' for worklist for '_6'
       not seen; adding to worklist for '_6'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'before (SN: 8 stmt: 0):  _6 = t_13(D)->counting;' for '_6'
      def stmt; terminating
     exiting: process_point
    exiting: processing worklist
    '_6' in 'ss_out' is needed to process:
      point: before (SN: 8 stmt: 0):  _6 = t_13(D)->counting;
      point: before (SN: 8 stmt: 1):  _7 = ~_6;
   exiting: state_purge_per_ssa_name
   entering: state_purge_per_ssa_name
    SSA name: '_7' within 'ss_out'
    def stmt: _7 = ~_6;
    used by stmt: if (_7 != 0)
    entering: add_to_worklist
     point: 'before (SN: 8 stmt: 2):  if (_7 != 0)' for worklist for '_7'
     not seen; adding to worklist for '_7'
    exiting: add_to_worklist
    last stmt in BB
    entering: add_to_worklist
     point: 'after SN: 8' for worklist for '_7'
     not seen; adding to worklist for '_7'
    exiting: add_to_worklist
    entering: processing worklist
     entering: process_point
      considering point: 'after SN: 8' for '_7'
      entering: add_to_worklist
       point: 'before (SN: 8 stmt: 2):  if (_7 != 0)' for worklist for '_7'
       already seen for '_7'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'before (SN: 8 stmt: 2):  if (_7 != 0)' for '_7'
      entering: add_to_worklist
       point: 'before (SN: 8 stmt: 1):  _7 = ~_6;' for worklist for '_7'
       not seen; adding to worklist for '_7'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'before (SN: 8 stmt: 1):  _7 = ~_6;' for '_7'
      def stmt; terminating
     exiting: process_point
    exiting: processing worklist
    '_7' in 'ss_out' is needed to process:
      point: before (SN: 8 stmt: 1):  _7 = ~_6;
      point: before (SN: 8 stmt: 2):  if (_7 != 0)
      point: after SN: 8
   exiting: state_purge_per_ssa_name
   entering: state_purge_per_ssa_name
    SSA name: '_8' within 'ss_out'
    def stmt: _8 = t_13(D)->uu.newstr;
    used by stmt: _9 = _8;
    entering: add_to_worklist
     point: 'before (SN: 9 stmt: 1):  _9 = _8;' for worklist for '_8'
     not seen; adding to worklist for '_8'
    exiting: add_to_worklist
    not last stmt in BB
    entering: processing worklist
     entering: process_point
      considering point: 'before (SN: 9 stmt: 1):  _9 = _8;' for '_8'
      entering: add_to_worklist
       point: 'before (SN: 9 stmt: 0):  _8 = t_13(D)->uu.newstr;' for worklist for '_8'
       not seen; adding to worklist for '_8'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'before (SN: 9 stmt: 0):  _8 = t_13(D)->uu.newstr;' for '_8'
      def stmt; terminating
     exiting: process_point
    exiting: processing worklist
    '_8' in 'ss_out' is needed to process:
      point: before (SN: 9 stmt: 0):  _8 = t_13(D)->uu.newstr;
      point: before (SN: 9 stmt: 1):  _9 = _8;
   exiting: state_purge_per_ssa_name
   entering: state_purge_per_ssa_name
    SSA name: '_9' within 'ss_out'
    def stmt: _9 = _8;
    used by stmt: *_9 = cc_17(D);
    entering: add_to_worklist
     point: 'before (SN: 9 stmt: 4):  *_9 = cc_17(D);' for worklist for '_9'
     not seen; adding to worklist for '_9'
    exiting: add_to_worklist
    last stmt in BB
    entering: add_to_worklist
     point: 'after SN: 9' for worklist for '_9'
     not seen; adding to worklist for '_9'
    exiting: add_to_worklist
    used by stmt: _10 = _9 + 1;
    entering: add_to_worklist
     point: 'before (SN: 9 stmt: 2):  _10 = _9 + 1;' for worklist for '_9'
     not seen; adding to worklist for '_9'
    exiting: add_to_worklist
    not last stmt in BB
    entering: processing worklist
     entering: process_point
      considering point: 'before (SN: 9 stmt: 2):  _10 = _9 + 1;' for '_9'
      entering: add_to_worklist
       point: 'before (SN: 9 stmt: 1):  _9 = _8;' for worklist for '_9'
       not seen; adding to worklist for '_9'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'before (SN: 9 stmt: 1):  _9 = _8;' for '_9'
      def stmt; terminating
     exiting: process_point
     entering: process_point
      considering point: 'after SN: 9' for '_9'
      entering: add_to_worklist
       point: 'before (SN: 9 stmt: 4):  *_9 = cc_17(D);' for worklist for '_9'
       already seen for '_9'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'before (SN: 9 stmt: 4):  *_9 = cc_17(D);' for '_9'
      entering: add_to_worklist
       point: 'before (SN: 9 stmt: 3):  t_13(D)->uu.newstr = _10;' for worklist for '_9'
       not seen; adding to worklist for '_9'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'before (SN: 9 stmt: 3):  t_13(D)->uu.newstr = _10;' for '_9'
      entering: add_to_worklist
       point: 'before (SN: 9 stmt: 2):  _10 = _9 + 1;' for worklist for '_9'
       already seen for '_9'
      exiting: add_to_worklist
     exiting: process_point
    exiting: processing worklist
    '_9' in 'ss_out' is needed to process:
      point: before (SN: 9 stmt: 1):  _9 = _8;
      point: before (SN: 9 stmt: 2):  _10 = _9 + 1;
      point: before (SN: 9 stmt: 3):  t_13(D)->uu.newstr = _10;
      point: before (SN: 9 stmt: 4):  *_9 = cc_17(D);
      point: after SN: 9
   exiting: state_purge_per_ssa_name
   entering: state_purge_per_ssa_name
    SSA name: '_10' within 'ss_out'
    def stmt: _10 = _9 + 1;
    used by stmt: t_13(D)->uu.newstr = _10;
    entering: add_to_worklist
     point: 'before (SN: 9 stmt: 3):  t_13(D)->uu.newstr = _10;' for worklist for '_10'
     not seen; adding to worklist for '_10'
    exiting: add_to_worklist
    not last stmt in BB
    entering: processing worklist
     entering: process_point
      considering point: 'before (SN: 9 stmt: 3):  t_13(D)->uu.newstr = _10;' for '_10'
      entering: add_to_worklist
       point: 'before (SN: 9 stmt: 2):  _10 = _9 + 1;' for worklist for '_10'
       not seen; adding to worklist for '_10'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'before (SN: 9 stmt: 2):  _10 = _9 + 1;' for '_10'
      def stmt; terminating
     exiting: process_point
    exiting: processing worklist
    '_10' in 'ss_out' is needed to process:
      point: before (SN: 9 stmt: 2):  _10 = _9 + 1;
      point: before (SN: 9 stmt: 3):  t_13(D)->uu.newstr = _10;
   exiting: state_purge_per_ssa_name
   entering: state_purge_per_ssa_name
    SSA name: 't_13(D)' within 'ss_out'
    def stmt: GIMPLE_NOP
    used by stmt: t_13(D)->uu.newstr = _10;
    entering: add_to_worklist
     point: 'before (SN: 9 stmt: 3):  t_13(D)->uu.newstr = _10;' for worklist for 't_13(D)'
     not seen; adding to worklist for 't_13(D)'
    exiting: add_to_worklist
    not last stmt in BB
    used by stmt: _8 = t_13(D)->uu.newstr;
    entering: add_to_worklist
     point: 'before (SN: 9 stmt: 0):  _8 = t_13(D)->uu.newstr;' for worklist for 't_13(D)'
     not seen; adding to worklist for 't_13(D)'
    exiting: add_to_worklist
    not last stmt in BB
    used by stmt: _6 = t_13(D)->counting;
    entering: add_to_worklist
     point: 'before (SN: 8 stmt: 0):  _6 = t_13(D)->counting;' for worklist for 't_13(D)'
     not seen; adding to worklist for 't_13(D)'
    exiting: add_to_worklist
    not last stmt in BB
    used by stmt: _3 = t_13(D)->counting;
    entering: add_to_worklist
     point: 'before (SN: 7 stmt: 3):  _3 = t_13(D)->counting;' for worklist for 't_13(D)'
     not seen; adding to worklist for 't_13(D)'
    exiting: add_to_worklist
    not last stmt in BB
    used by stmt: _1 = t_13(D)->counting;
    entering: add_to_worklist
     point: 'before (SN: 7 stmt: 0):  _1 = t_13(D)->counting;' for worklist for 't_13(D)'
     not seen; adding to worklist for 't_13(D)'
    exiting: add_to_worklist
    not last stmt in BB
    entering: processing worklist
     entering: process_point
      considering point: 'before (SN: 7 stmt: 0):  _1 = t_13(D)->counting;' for 't_13(D)'
      entering: add_to_worklist
       point: 'before SN: 7 (from SN: 6 (bb: 0)) ' for worklist for 't_13(D)'
       not seen; adding to worklist for 't_13(D)'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'before SN: 7 (from SN: 6 (bb: 0)) ' for 't_13(D)'
      entering: add_to_worklist
       point: 'after SN: 6' for worklist for 't_13(D)'
       not seen; adding to worklist for 't_13(D)'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'after SN: 6' for 't_13(D)'
      entering: add_to_worklist
       point: 'before SN: 6 (NULL from-edge) ' for worklist for 't_13(D)'
       not seen; adding to worklist for 't_13(D)'
      exiting: add_to_worklist
      entering: add_to_worklist
       point: 'before SN: 6 (NULL from-edge) ' for worklist for 't_13(D)'
       already seen for 't_13(D)'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'before SN: 6 (NULL from-edge) ' for 't_13(D)'
     exiting: process_point
     entering: process_point
      considering point: 'before (SN: 7 stmt: 3):  _3 = t_13(D)->counting;' for 't_13(D)'
      entering: add_to_worklist
       point: 'before (SN: 7 stmt: 2):  __analyzer_describe (0, _2);' for worklist for 't_13(D)'
       not seen; adding to worklist for 't_13(D)'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'before (SN: 7 stmt: 2):  __analyzer_describe (0, _2);' for 't_13(D)'
      entering: add_to_worklist
       point: 'before (SN: 7 stmt: 1):  _2 = (int) _1;' for worklist for 't_13(D)'
       not seen; adding to worklist for 't_13(D)'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'before (SN: 7 stmt: 1):  _2 = (int) _1;' for 't_13(D)'
      entering: add_to_worklist
       point: 'before (SN: 7 stmt: 0):  _1 = t_13(D)->counting;' for worklist for 't_13(D)'
       already seen for 't_13(D)'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'before (SN: 8 stmt: 0):  _6 = t_13(D)->counting;' for 't_13(D)'
      entering: add_to_worklist
       point: 'before SN: 8 (NULL from-edge) ' for worklist for 't_13(D)'
       not seen; adding to worklist for 't_13(D)'
      exiting: add_to_worklist
      entering: add_to_worklist
       point: 'before SN: 8 (NULL from-edge) ' for worklist for 't_13(D)'
       already seen for 't_13(D)'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'before SN: 8 (NULL from-edge) ' for 't_13(D)'
      entering: add_to_worklist
       point: 'after SN: 7' for worklist for 't_13(D)'
       not seen; adding to worklist for 't_13(D)'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'after SN: 7' for 't_13(D)'
      entering: add_to_worklist
       point: 'before (SN: 7 stmt: 6):  __analyzer_eval (_5);' for worklist for 't_13(D)'
       not seen; adding to worklist for 't_13(D)'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'before (SN: 7 stmt: 6):  __analyzer_eval (_5);' for 't_13(D)'
      entering: add_to_worklist
       point: 'before (SN: 7 stmt: 5):  _5 = (int) _4;' for worklist for 't_13(D)'
       not seen; adding to worklist for 't_13(D)'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'before (SN: 7 stmt: 5):  _5 = (int) _4;' for 't_13(D)'
      entering: add_to_worklist
       point: 'before (SN: 7 stmt: 4):  _4 = ~_3;' for worklist for 't_13(D)'
       not seen; adding to worklist for 't_13(D)'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'before (SN: 7 stmt: 4):  _4 = ~_3;' for 't_13(D)'
      entering: add_to_worklist
       point: 'before (SN: 7 stmt: 3):  _3 = t_13(D)->counting;' for worklist for 't_13(D)'
       already seen for 't_13(D)'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'before (SN: 9 stmt: 0):  _8 = t_13(D)->uu.newstr;' for 't_13(D)'
      entering: add_to_worklist
       point: 'before SN: 9 (from SN: 8 (bb: 2)) ' for worklist for 't_13(D)'
       not seen; adding to worklist for 't_13(D)'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'before SN: 9 (from SN: 8 (bb: 2)) ' for 't_13(D)'
      entering: add_to_worklist
       point: 'after SN: 8' for worklist for 't_13(D)'
       not seen; adding to worklist for 't_13(D)'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'after SN: 8' for 't_13(D)'
      entering: add_to_worklist
       point: 'before (SN: 8 stmt: 2):  if (_7 != 0)' for worklist for 't_13(D)'
       not seen; adding to worklist for 't_13(D)'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'before (SN: 8 stmt: 2):  if (_7 != 0)' for 't_13(D)'
      entering: add_to_worklist
       point: 'before (SN: 8 stmt: 1):  _7 = ~_6;' for worklist for 't_13(D)'
       not seen; adding to worklist for 't_13(D)'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'before (SN: 8 stmt: 1):  _7 = ~_6;' for 't_13(D)'
      entering: add_to_worklist
       point: 'before (SN: 8 stmt: 0):  _6 = t_13(D)->counting;' for worklist for 't_13(D)'
       already seen for 't_13(D)'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'before (SN: 9 stmt: 3):  t_13(D)->uu.newstr = _10;' for 't_13(D)'
      entering: add_to_worklist
       point: 'before (SN: 9 stmt: 2):  _10 = _9 + 1;' for worklist for 't_13(D)'
       not seen; adding to worklist for 't_13(D)'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'before (SN: 9 stmt: 2):  _10 = _9 + 1;' for 't_13(D)'
      entering: add_to_worklist
       point: 'before (SN: 9 stmt: 1):  _9 = _8;' for worklist for 't_13(D)'
       not seen; adding to worklist for 't_13(D)'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'before (SN: 9 stmt: 1):  _9 = _8;' for 't_13(D)'
      entering: add_to_worklist
       point: 'before (SN: 9 stmt: 0):  _8 = t_13(D)->uu.newstr;' for worklist for 't_13(D)'
       already seen for 't_13(D)'
      exiting: add_to_worklist
     exiting: process_point
    exiting: processing worklist
    't_13(D)' in 'ss_out' is needed to process:
      point: before SN: 6 (NULL from-edge) 
      point: after SN: 6
      point: before SN: 7 (from SN: 6 (bb: 0)) 
      point: before (SN: 7 stmt: 0):  _1 = t_13(D)->counting;
      point: before (SN: 7 stmt: 1):  _2 = (int) _1;
      point: before (SN: 7 stmt: 2):  __analyzer_describe (0, _2);
      point: before (SN: 7 stmt: 3):  _3 = t_13(D)->counting;
      point: before (SN: 7 stmt: 4):  _4 = ~_3;
      point: before (SN: 7 stmt: 5):  _5 = (int) _4;
      point: before (SN: 7 stmt: 6):  __analyzer_eval (_5);
      point: after SN: 7
      point: before SN: 8 (NULL from-edge) 
      point: before (SN: 8 stmt: 0):  _6 = t_13(D)->counting;
      point: before (SN: 8 stmt: 1):  _7 = ~_6;
      point: before (SN: 8 stmt: 2):  if (_7 != 0)
      point: after SN: 8
      point: before SN: 9 (from SN: 8 (bb: 2)) 
      point: before (SN: 9 stmt: 0):  _8 = t_13(D)->uu.newstr;
      point: before (SN: 9 stmt: 1):  _9 = _8;
      point: before (SN: 9 stmt: 2):  _10 = _9 + 1;
      point: before (SN: 9 stmt: 3):  t_13(D)->uu.newstr = _10;
   exiting: state_purge_per_ssa_name
   entering: state_purge_per_ssa_name
    SSA name: 'cc_17(D)' within 'ss_out'
    def stmt: GIMPLE_NOP
    used by stmt: *_9 = cc_17(D);
    entering: add_to_worklist
     point: 'before (SN: 9 stmt: 4):  *_9 = cc_17(D);' for worklist for 'cc_17(D)'
     not seen; adding to worklist for 'cc_17(D)'
    exiting: add_to_worklist
    last stmt in BB
    entering: add_to_worklist
     point: 'after SN: 9' for worklist for 'cc_17(D)'
     not seen; adding to worklist for 'cc_17(D)'
    exiting: add_to_worklist
    entering: processing worklist
     entering: process_point
      considering point: 'after SN: 9' for 'cc_17(D)'
      entering: add_to_worklist
       point: 'before (SN: 9 stmt: 4):  *_9 = cc_17(D);' for worklist for 'cc_17(D)'
       already seen for 'cc_17(D)'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'before (SN: 9 stmt: 4):  *_9 = cc_17(D);' for 'cc_17(D)'
      entering: add_to_worklist
       point: 'before (SN: 9 stmt: 3):  t_13(D)->uu.newstr = _10;' for worklist for 'cc_17(D)'
       not seen; adding to worklist for 'cc_17(D)'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'before (SN: 9 stmt: 3):  t_13(D)->uu.newstr = _10;' for 'cc_17(D)'
      entering: add_to_worklist
       point: 'before (SN: 9 stmt: 2):  _10 = _9 + 1;' for worklist for 'cc_17(D)'
       not seen; adding to worklist for 'cc_17(D)'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'before (SN: 9 stmt: 2):  _10 = _9 + 1;' for 'cc_17(D)'
      entering: add_to_worklist
       point: 'before (SN: 9 stmt: 1):  _9 = _8;' for worklist for 'cc_17(D)'
       not seen; adding to worklist for 'cc_17(D)'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'before (SN: 9 stmt: 1):  _9 = _8;' for 'cc_17(D)'
      entering: add_to_worklist
       point: 'before (SN: 9 stmt: 0):  _8 = t_13(D)->uu.newstr;' for worklist for 'cc_17(D)'
       not seen; adding to worklist for 'cc_17(D)'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'before (SN: 9 stmt: 0):  _8 = t_13(D)->uu.newstr;' for 'cc_17(D)'
      entering: add_to_worklist
       point: 'before SN: 9 (from SN: 8 (bb: 2)) ' for worklist for 'cc_17(D)'
       not seen; adding to worklist for 'cc_17(D)'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'before SN: 9 (from SN: 8 (bb: 2)) ' for 'cc_17(D)'
      entering: add_to_worklist
       point: 'after SN: 8' for worklist for 'cc_17(D)'
       not seen; adding to worklist for 'cc_17(D)'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'after SN: 8' for 'cc_17(D)'
      entering: add_to_worklist
       point: 'before (SN: 8 stmt: 2):  if (_7 != 0)' for worklist for 'cc_17(D)'
       not seen; adding to worklist for 'cc_17(D)'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'before (SN: 8 stmt: 2):  if (_7 != 0)' for 'cc_17(D)'
      entering: add_to_worklist
       point: 'before (SN: 8 stmt: 1):  _7 = ~_6;' for worklist for 'cc_17(D)'
       not seen; adding to worklist for 'cc_17(D)'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'before (SN: 8 stmt: 1):  _7 = ~_6;' for 'cc_17(D)'
      entering: add_to_worklist
       point: 'before (SN: 8 stmt: 0):  _6 = t_13(D)->counting;' for worklist for 'cc_17(D)'
       not seen; adding to worklist for 'cc_17(D)'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'before (SN: 8 stmt: 0):  _6 = t_13(D)->counting;' for 'cc_17(D)'
      entering: add_to_worklist
       point: 'before SN: 8 (NULL from-edge) ' for worklist for 'cc_17(D)'
       not seen; adding to worklist for 'cc_17(D)'
      exiting: add_to_worklist
      entering: add_to_worklist
       point: 'before SN: 8 (NULL from-edge) ' for worklist for 'cc_17(D)'
       already seen for 'cc_17(D)'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'before SN: 8 (NULL from-edge) ' for 'cc_17(D)'
      entering: add_to_worklist
       point: 'after SN: 7' for worklist for 'cc_17(D)'
       not seen; adding to worklist for 'cc_17(D)'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'after SN: 7' for 'cc_17(D)'
      entering: add_to_worklist
       point: 'before (SN: 7 stmt: 6):  __analyzer_eval (_5);' for worklist for 'cc_17(D)'
       not seen; adding to worklist for 'cc_17(D)'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'before (SN: 7 stmt: 6):  __analyzer_eval (_5);' for 'cc_17(D)'
      entering: add_to_worklist
       point: 'before (SN: 7 stmt: 5):  _5 = (int) _4;' for worklist for 'cc_17(D)'
       not seen; adding to worklist for 'cc_17(D)'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'before (SN: 7 stmt: 5):  _5 = (int) _4;' for 'cc_17(D)'
      entering: add_to_worklist
       point: 'before (SN: 7 stmt: 4):  _4 = ~_3;' for worklist for 'cc_17(D)'
       not seen; adding to worklist for 'cc_17(D)'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'before (SN: 7 stmt: 4):  _4 = ~_3;' for 'cc_17(D)'
      entering: add_to_worklist
       point: 'before (SN: 7 stmt: 3):  _3 = t_13(D)->counting;' for worklist for 'cc_17(D)'
       not seen; adding to worklist for 'cc_17(D)'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'before (SN: 7 stmt: 3):  _3 = t_13(D)->counting;' for 'cc_17(D)'
      entering: add_to_worklist
       point: 'before (SN: 7 stmt: 2):  __analyzer_describe (0, _2);' for worklist for 'cc_17(D)'
       not seen; adding to worklist for 'cc_17(D)'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'before (SN: 7 stmt: 2):  __analyzer_describe (0, _2);' for 'cc_17(D)'
      entering: add_to_worklist
       point: 'before (SN: 7 stmt: 1):  _2 = (int) _1;' for worklist for 'cc_17(D)'
       not seen; adding to worklist for 'cc_17(D)'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'before (SN: 7 stmt: 1):  _2 = (int) _1;' for 'cc_17(D)'
      entering: add_to_worklist
       point: 'before (SN: 7 stmt: 0):  _1 = t_13(D)->counting;' for worklist for 'cc_17(D)'
       not seen; adding to worklist for 'cc_17(D)'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'before (SN: 7 stmt: 0):  _1 = t_13(D)->counting;' for 'cc_17(D)'
      entering: add_to_worklist
       point: 'before SN: 7 (from SN: 6 (bb: 0)) ' for worklist for 'cc_17(D)'
       not seen; adding to worklist for 'cc_17(D)'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'before SN: 7 (from SN: 6 (bb: 0)) ' for 'cc_17(D)'
      entering: add_to_worklist
       point: 'after SN: 6' for worklist for 'cc_17(D)'
       not seen; adding to worklist for 'cc_17(D)'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'after SN: 6' for 'cc_17(D)'
      entering: add_to_worklist
       point: 'before SN: 6 (NULL from-edge) ' for worklist for 'cc_17(D)'
       not seen; adding to worklist for 'cc_17(D)'
      exiting: add_to_worklist
      entering: add_to_worklist
       point: 'before SN: 6 (NULL from-edge) ' for worklist for 'cc_17(D)'
       already seen for 'cc_17(D)'
      exiting: add_to_worklist
     exiting: process_point
     entering: process_point
      considering point: 'before SN: 6 (NULL from-edge) ' for 'cc_17(D)'
     exiting: process_point
    exiting: processing worklist
    'cc_17(D)' in 'ss_out' is needed to process:
      point: before SN: 6 (NULL from-edge) 
      point: after SN: 6
      point: before SN: 7 (from SN: 6 (bb: 0)) 
      point: before (SN: 7 stmt: 0):  _1 = t_13(D)->counting;
      point: before (SN: 7 stmt: 1):  _2 = (int) _1;
      point: before (SN: 7 stmt: 2):  __analyzer_describe (0, _2);
      point: before (SN: 7 stmt: 3):  _3 = t_13(D)->counting;
      point: before (SN: 7 stmt: 4):  _4 = ~_3;
      point: before (SN: 7 stmt: 5):  _5 = (int) _4;
      point: before (SN: 7 stmt: 6):  __analyzer_eval (_5);
      point: after SN: 7
      point: before SN: 8 (NULL from-edge) 
      point: before (SN: 8 stmt: 0):  _6 = t_13(D)->counting;
      point: before (SN: 8 stmt: 1):  _7 = ~_6;
      point: before (SN: 8 stmt: 2):  if (_7 != 0)
      point: after SN: 8
      point: before SN: 9 (from SN: 8 (bb: 2)) 
      point: before (SN: 9 stmt: 0):  _8 = t_13(D)->uu.newstr;
      point: before (SN: 9 stmt: 1):  _9 = _8;
      point: before (SN: 9 stmt: 2):  _10 = _9 + 1;
      point: before (SN: 9 stmt: 3):  t_13(D)->uu.newstr = _10;
      point: before (SN: 9 stmt: 4):  *_9 = cc_17(D);
      point: after SN: 9
   exiting: state_purge_per_ssa_name
   function: ss_init
   function: __analyzer_eval
   SN: 0
   SN: 1
   entering: on_store
    on_store: ss = ss_init ();; base: 'ss', op: 'ss'
   exiting: on_store
   SN: 2
   entering: on_load
    on_load: _1 = ss.counting;; base: 'ss', op: 'ss.counting'
   exiting: on_load
   entering: on_addr
    on_addr: ss_out (&ss, 97);; base: 'ss', op: '&ss'
   exiting: on_addr
   SN: 3
   entering: on_store
    on_store: ss ={v} {CLOBBER(eol)};; base: 'ss', op: 'ss'
   exiting: on_store
   SN: 4
   SN: 5
   SN: 6
   SN: 7
   entering: on_load
    on_load: _1 = t_13(D)->counting;; base: '*t_13(D)', op: 't_13(D)->counting'
   exiting: on_load
   entering: on_load
    on_load: _3 = t_13(D)->counting;; base: '*t_13(D)', op: 't_13(D)->counting'
   exiting: on_load
   SN: 8
   entering: on_load
    on_load: _6 = t_13(D)->counting;; base: '*t_13(D)', op: 't_13(D)->counting'
   exiting: on_load
   SN: 9
   entering: on_load
    on_load: _8 = t_13(D)->uu.newstr;; base: '*t_13(D)', op: 't_13(D)->uu.newstr'
   exiting: on_load
   entering: on_store
    on_store: t_13(D)->uu.newstr = _10;; base: '*t_13(D)', op: 't_13(D)->uu.newstr'
   exiting: on_store
   entering: on_store
    on_store: *_9 = cc_17(D);; base: '*_9', op: '*_9'
   exiting: on_store
   SN: 10
   SN: 11
   SN: 12
   SN: 13
   entering: on_store
    on_store: rr = {};; base: 'rr', op: 'rr'
   exiting: on_store
   entering: on_store
    on_store: rr.counting = 1;; base: 'rr', op: 'rr.counting'
   exiting: on_store
   entering: on_store
    on_store: D.2757 = rr;; base: '<anonymous>', op: '<anonymous>'
   exiting: on_store
   entering: on_load
    on_load: D.2757 = rr;; base: 'rr', op: 'rr'
   exiting: on_load
   entering: on_store
    on_store: rr ={v} {CLOBBER(eol)};; base: 'rr', op: 'rr'
   exiting: on_store
   SN: 14
   entering: on_load
    on_load: return D.2757;; base: '<anonymous>', op: '<anonymous>'
   exiting: on_load
   SN: 15
   SN: 16
   SN: 17
   SN: 18
   entering: void ana::state_purge_per_decl::process_worklists(const ana::state_purge_map&, ana::region_model_manager*)
    decl: 'ss' within 'main'
    entering: processing worklist
     entering: process_point_backwards
      considering point: 'after SN: 2' for 'ss'
      entering: add_to_worklist
       point: 'before (SN: 2 stmt: 3):  ss_out (&ss, 97);' for worklist for 'ss'
       not seen; adding to worklist for 'ss'
      exiting: add_to_worklist
     exiting: process_point_backwards
     entering: process_point_backwards
      considering point: 'before (SN: 2 stmt: 3):  ss_out (&ss, 97);' for 'ss'
      entering: add_to_worklist
       point: 'before (SN: 2 stmt: 2):  __analyzer_describe (0, _2);' for worklist for 'ss'
       not seen; adding to worklist for 'ss'
      exiting: add_to_worklist
     exiting: process_point_backwards
     entering: process_point_backwards
      considering point: 'before (SN: 2 stmt: 2):  __analyzer_describe (0, _2);' for 'ss'
      entering: add_to_worklist
       point: 'before (SN: 2 stmt: 1):  _2 = (int) _1;' for worklist for 'ss'
       not seen; adding to worklist for 'ss'
      exiting: add_to_worklist
     exiting: process_point_backwards
     entering: process_point_backwards
      considering point: 'before (SN: 2 stmt: 1):  _2 = (int) _1;' for 'ss'
      entering: add_to_worklist
       point: 'before (SN: 2 stmt: 0):  _1 = ss.counting;' for worklist for 'ss'
       not seen; adding to worklist for 'ss'
      exiting: add_to_worklist
     exiting: process_point_backwards
     entering: process_point_backwards
      considering point: 'before (SN: 2 stmt: 0):  _1 = ss.counting;' for 'ss'
      entering: add_to_worklist
       point: 'before SN: 2 (NULL from-edge) ' for worklist for 'ss'
       not seen; adding to worklist for 'ss'
      exiting: add_to_worklist
      entering: add_to_worklist
       point: 'before SN: 2 (NULL from-edge) ' for worklist for 'ss'
       already seen for 'ss'
      exiting: add_to_worklist
     exiting: process_point_backwards
     entering: process_point_backwards
      considering point: 'before SN: 2 (NULL from-edge) ' for 'ss'
      entering: add_to_worklist
       point: 'after SN: 1' for worklist for 'ss'
       not seen; adding to worklist for 'ss'
      exiting: add_to_worklist
     exiting: process_point_backwards
     entering: process_point_backwards
      considering point: 'after SN: 1' for 'ss'
      entering: add_to_worklist
       point: 'before (SN: 1 stmt: 0):  ss = ss_init ();' for worklist for 'ss'
       not seen; adding to worklist for 'ss'
      exiting: add_to_worklist
     exiting: process_point_backwards
     entering: process_point_backwards
      considering point: 'before (SN: 1 stmt: 0):  ss = ss_init ();' for 'ss'
      stmt fully overwrites 'ss'; terminating
     exiting: process_point_backwards
     entering: process_point_backwards
      considering point: 'before (SN: 2 stmt: 0):  _1 = ss.counting;' for 'ss'
      entering: add_to_worklist
       point: 'before SN: 2 (NULL from-edge) ' for worklist for 'ss'
       already seen for 'ss'
      exiting: add_to_worklist
      entering: add_to_worklist
       point: 'before SN: 2 (NULL from-edge) ' for worklist for 'ss'
       already seen for 'ss'
      exiting: add_to_worklist
     exiting: process_point_backwards
     entering: process_point_backwards
      considering point: 'before (SN: 2 stmt: 3):  ss_out (&ss, 97);' for 'ss'
      entering: add_to_worklist
       point: 'before (SN: 2 stmt: 2):  __analyzer_describe (0, _2);' for worklist for 'ss'
       already seen for 'ss'
      exiting: add_to_worklist
     exiting: process_point_backwards
    exiting: processing worklist
    entering: processing worklist
     entering: process_point_forwards
      considering point: 'before (SN: 2 stmt: 3):  ss_out (&ss, 97);' for 'ss'
      entering: add_to_worklist
       point: 'after SN: 2' for worklist for 'ss'
       not seen; adding to worklist for 'ss'
      exiting: add_to_worklist
     exiting: process_point_forwards
     entering: process_point_forwards
      considering point: 'after SN: 2' for 'ss'
      entering: add_to_worklist
       point: 'before SN: 3 (NULL from-edge) ' for worklist for 'ss'
       not seen; adding to worklist for 'ss'
      exiting: add_to_worklist
     exiting: process_point_forwards
     entering: process_point_forwards
      considering point: 'before SN: 3 (NULL from-edge) ' for 'ss'
      entering: add_to_worklist
       point: 'before (SN: 3 stmt: 0):  ss ={v} {CLOBBER(eol)};' for worklist for 'ss'
       not seen; adding to worklist for 'ss'
      exiting: add_to_worklist
     exiting: process_point_forwards
     entering: process_point_forwards
      considering point: 'before (SN: 3 stmt: 0):  ss ={v} {CLOBBER(eol)};' for 'ss'
      entering: add_to_worklist
       point: 'before (SN: 3 stmt: 1):  _8 = 0;' for worklist for 'ss'
       not seen; adding to worklist for 'ss'
      exiting: add_to_worklist
     exiting: process_point_forwards
     entering: process_point_forwards
      considering point: 'before (SN: 3 stmt: 1):  _8 = 0;' for 'ss'
      entering: add_to_worklist
       point: 'after SN: 3' for worklist for 'ss'
       not seen; adding to worklist for 'ss'
      exiting: add_to_worklist
     exiting: process_point_forwards
     entering: process_point_forwards
      considering point: 'after SN: 3' for 'ss'
      entering: add_to_worklist
       point: 'before SN: 4 (from SN: 3 (bb: 2)) ' for worklist for 'ss'
       not seen; adding to worklist for 'ss'
      exiting: add_to_worklist
     exiting: process_point_forwards
     entering: process_point_forwards
      considering point: 'before SN: 4 (from SN: 3 (bb: 2)) ' for 'ss'
      entering: add_to_worklist
       point: 'before (SN: 4 stmt: 0):  <L0>:' for worklist for 'ss'
       not seen; adding to worklist for 'ss'
      exiting: add_to_worklist
     exiting: process_point_forwards
     entering: process_point_forwards
      considering point: 'before (SN: 4 stmt: 0):  <L0>:' for 'ss'
      entering: add_to_worklist
       point: 'before (SN: 4 stmt: 1):  return _8;' for worklist for 'ss'
       not seen; adding to worklist for 'ss'
      exiting: add_to_worklist
     exiting: process_point_forwards
     entering: process_point_forwards
      considering point: 'before (SN: 4 stmt: 1):  return _8;' for 'ss'
      entering: add_to_worklist
       point: 'after SN: 4' for worklist for 'ss'
       not seen; adding to worklist for 'ss'
      exiting: add_to_worklist
     exiting: process_point_forwards
     entering: process_point_forwards
      considering point: 'after SN: 4' for 'ss'
      entering: add_to_worklist
       point: 'before SN: 5 (from SN: 4 (bb: 3)) ' for worklist for 'ss'
       not seen; adding to worklist for 'ss'
      exiting: add_to_worklist
     exiting: process_point_forwards
     entering: process_point_forwards
      considering point: 'before SN: 5 (from SN: 4 (bb: 3)) ' for 'ss'
      entering: add_to_worklist
       point: 'after SN: 5' for worklist for 'ss'
       not seen; adding to worklist for 'ss'
      exiting: add_to_worklist
     exiting: process_point_forwards
     entering: process_point_forwards
      considering point: 'after SN: 5' for 'ss'
     exiting: process_point_forwards
    exiting: processing worklist
   exiting: void ana::state_purge_per_decl::process_worklists(const ana::state_purge_map&, ana::region_model_manager*)
   entering: void ana::state_purge_per_decl::process_worklists(const ana::state_purge_map&, ana::region_model_manager*)
    decl: 'rr' within 'ss_init'
    entering: processing worklist
     entering: process_point_backwards
      considering point: 'before (SN: 13 stmt: 2):  D.2757 = rr;' for 'rr'
      entering: add_to_worklist
       point: 'before (SN: 13 stmt: 1):  rr.counting = 1;' for worklist for 'rr'
       not seen; adding to worklist for 'rr'
      exiting: add_to_worklist
     exiting: process_point_backwards
     entering: process_point_backwards
      considering point: 'before (SN: 13 stmt: 1):  rr.counting = 1;' for 'rr'
      entering: add_to_worklist
       point: 'before (SN: 13 stmt: 0):  rr = {};' for worklist for 'rr'
       not seen; adding to worklist for 'rr'
      exiting: add_to_worklist
     exiting: process_point_backwards
     entering: process_point_backwards
      considering point: 'before (SN: 13 stmt: 0):  rr = {};' for 'rr'
      stmt fully overwrites 'rr'; terminating
     exiting: process_point_backwards
    exiting: processing worklist
    entering: processing worklist
    exiting: processing worklist
   exiting: void ana::state_purge_per_decl::process_worklists(const ana::state_purge_map&, ana::region_model_manager*)
   entering: void ana::state_purge_per_decl::process_worklists(const ana::state_purge_map&, ana::region_model_manager*)
    decl: '<anonymous>' within 'ss_init'
    entering: processing worklist
     entering: process_point_backwards
      considering point: 'after SN: 14' for '<anonymous>'
      entering: add_to_worklist
       point: 'before (SN: 14 stmt: 1):  return D.2757;' for worklist for '<anonymous>'
       not seen; adding to worklist for '<anonymous>'
      exiting: add_to_worklist
     exiting: process_point_backwards
     entering: process_point_backwards
      considering point: 'before (SN: 14 stmt: 1):  return D.2757;' for '<anonymous>'
      entering: add_to_worklist
       point: 'before (SN: 14 stmt: 0):  <L1>:' for worklist for '<anonymous>'
       not seen; adding to worklist for '<anonymous>'
      exiting: add_to_worklist
     exiting: process_point_backwards
     entering: process_point_backwards
      considering point: 'before (SN: 14 stmt: 0):  <L1>:' for '<anonymous>'
      entering: add_to_worklist
       point: 'before SN: 14 (from SN: 13 (bb: 2)) ' for worklist for '<anonymous>'
       not seen; adding to worklist for '<anonymous>'
      exiting: add_to_worklist
     exiting: process_point_backwards
     entering: process_point_backwards
      considering point: 'before SN: 14 (from SN: 13 (bb: 2)) ' for '<anonymous>'
      entering: add_to_worklist
       point: 'after SN: 13' for worklist for '<anonymous>'
       not seen; adding to worklist for '<anonymous>'
      exiting: add_to_worklist
     exiting: process_point_backwards
     entering: process_point_backwards
      considering point: 'after SN: 13' for '<anonymous>'
      entering: add_to_worklist
       point: 'before (SN: 13 stmt: 3):  rr ={v} {CLOBBER(eol)};' for worklist for '<anonymous>'
       not seen; adding to worklist for '<anonymous>'
      exiting: add_to_worklist
     exiting: process_point_backwards
     entering: process_point_backwards
      considering point: 'before (SN: 13 stmt: 3):  rr ={v} {CLOBBER(eol)};' for '<anonymous>'
      entering: add_to_worklist
       point: 'before (SN: 13 stmt: 2):  D.2757 = rr;' for worklist for '<anonymous>'
       not seen; adding to worklist for '<anonymous>'
      exiting: add_to_worklist
     exiting: process_point_backwards
     entering: process_point_backwards
      considering point: 'before (SN: 13 stmt: 2):  D.2757 = rr;' for '<anonymous>'
      stmt fully overwrites '<anonymous>'; terminating
     exiting: process_point_backwards
     entering: process_point_backwards
      considering point: 'before (SN: 14 stmt: 1):  return D.2757;' for '<anonymous>'
      entering: add_to_worklist
       point: 'before (SN: 14 stmt: 0):  <L1>:' for worklist for '<anonymous>'
       already seen for '<anonymous>'
      exiting: add_to_worklist
     exiting: process_point_backwards
    exiting: processing worklist
    entering: processing worklist
    exiting: processing worklist
   exiting: void ana::state_purge_per_decl::process_worklists(const ana::state_purge_map&, ana::region_model_manager*)
  exiting: state_purge_map
  checkers[0]: malloc
  checkers[1]: file
  checkers[2]: file-descriptor
  checkers[3]: sensitive
  checkers[4]: signal
  checkers[5]: va_list
  entering: ana::analysis_plan::analysis_plan(const ana::supergraph&, ana::logger*)


 ordered call graph: analysis_plan
__analyzer_describe/4 (__analyzer_describe)
  Type: function
  Visibility: semantic_interposition external public
  References: 
  Referring: 
  Availability: not_available
  Function flags:
  Called by: main/3 ss_out/2 
  Calls: 
__analyzer_eval/0 (__analyzer_eval)
  Type: function definition analyzed
  Visibility: force_output externally_visible semantic_interposition no_reorder public
  References: 
  Referring: 
  Availability: available
  Function flags: body
  Called by: ss_out/2 
  Calls: 
ss_init/1 (ss_init)
  Type: function definition analyzed
  Visibility: force_output externally_visible semantic_interposition no_reorder public
  References: 
  Referring: 
  Availability: available
  Function flags: body
  Called by: main/3 
  Calls: 
ss_out/2 (ss_out)
  Type: function definition analyzed
  Visibility: force_output externally_visible semantic_interposition no_reorder public
  References: 
  Referring: 
  Availability: available
  Function flags: body
  Called by: main/3 
  Calls: __analyzer_eval/0 __analyzer_describe/4 
main/3 (main)
  Type: function definition analyzed
  Visibility: force_output externally_visible semantic_interposition no_reorder public
  References: 
  Referring: 
  Availability: available
  Function flags: body
  Called by: 
  Calls: ss_out/2 __analyzer_describe/4 ss_init/1 

  exiting: ana::analysis_plan::analysis_plan(const ana::supergraph&, ana::logger*)
  entering: ana::strongly_connected_components::strongly_connected_components(const ana::supergraph&, ana::logger*)
  exiting: ana::strongly_connected_components::strongly_connected_components(const ana::supergraph&, ana::logger*)
  entering: get_or_create_node
   point: callstring: [] origin
   state: {rmodel: {stack depth: 0 {}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
   entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
   exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
   pruned_state: {rmodel: {stack depth: 0 {}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
   stack depth: 0 {}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}created EN: 0
   point: callstring: [] origin
   pruned_state: {rmodel: {stack depth: 0 {}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
  exiting: get_or_create_node
  entering: void ana::exploded_graph::build_initial_worklist()
   traversing 'main' (all checks passed)
   entering: get_or_create_node
    point: callstring: [] before SN: 0 (NULL from-edge) 
    state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    stack depth: 1 {frame (index 0): frame: 'main'@1}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}created EN: 1
    point: callstring: [] before SN: 0 (NULL from-edge) 
    pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
   exiting: get_or_create_node
   creating edge EN: 0 -> EN: 1
   created EN 1 for 'main' entrypoint
   traversing 'ss_out' (all checks passed)
   entering: get_or_create_node
    point: callstring: [] before SN: 6 (NULL from-edge) 
    state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}created EN: 2
    point: callstring: [] before SN: 6 (NULL from-edge) 
    pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
   exiting: get_or_create_node
   creating edge EN: 0 -> EN: 2
   created EN 2 for 'ss_out' entrypoint
   traversing 'ss_init' (all checks passed)
   entering: get_or_create_node
    point: callstring: [] before SN: 12 (NULL from-edge) 
    state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}created EN: 3
    point: callstring: [] before SN: 12 (NULL from-edge) 
    pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
   exiting: get_or_create_node
   creating edge EN: 0 -> EN: 3
   created EN 3 for 'ss_init' entrypoint
   not traversing '__analyzer_eval' (starts with '__analyzer_')
  exiting: void ana::exploded_graph::build_initial_worklist()
  entering: void ana::exploded_graph::process_worklist()
   next to process: EN: 0
   entering: process_node: EN: 0
    point: callstring: [] origin, state: {rmodel: {stack depth: 0 {}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
   exiting: process_node
   next to process: EN: 1
   entering: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
   exiting: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
   peek worklist: EN: 2
   entering: process_node: EN: 1
    point: callstring: [] before SN: 0 (NULL from-edge) , state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    entering: get_or_create_node
     point: callstring: [] after SN: 0
     state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     stack depth: 1 {frame (index 0): frame: 'main'@1}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}created EN: 4
     point: callstring: [] after SN: 0
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    exiting: get_or_create_node
    creating edge EN: 1 -> EN: 4
   exiting: process_node
   next to process: EN: 4
   peek worklist: EN: 2
   entering: process_node: EN: 4
    point: callstring: [] after SN: 0, state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    considering SN: 0 -> SN: 1 ( (flags FALLTHRU))
    entering: on_edge
     entering: on_edge
     exiting: on_edge
     entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
      src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
      dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
      uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
      src_state known reachable svalues:
      dest_state maybe reachable svalues:
     exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    exiting: on_edge
    entering: get_or_create_node
     point: callstring: [] before SN: 1 (from SN: 0 (bb: 0)) 
     state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     stack depth: 1 {frame (index 0): frame: 'main'@1}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}created EN: 5
     point: callstring: [] before SN: 1 (from SN: 0 (bb: 0)) 
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    exiting: get_or_create_node
    creating edge EN: 4 -> EN: 5
   exiting: process_node
   next to process: EN: 5
   entering: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
   exiting: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
   peek worklist: EN: 2
   entering: process_node: EN: 5
    point: callstring: [] before SN: 1 (from SN: 0 (bb: 0)) , state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
     dest_state maybe reachable svalues:
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: get_or_create_node
     point: callstring: [] before (SN: 1 stmt: 0):  ss = ss_init ();
     state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     stack depth: 1 {frame (index 0): frame: 'main'@1}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}created EN: 6
     point: callstring: [] before (SN: 1 stmt: 0):  ss = ss_init ();
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    exiting: get_or_create_node
    creating edge EN: 5 -> EN: 6
   exiting: process_node
   next to process: EN: 6
   peek worklist: EN: 2
   entering: process_node: EN: 6
    point: callstring: [] before (SN: 1 stmt: 0):  ss = ss_init ();, state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    entering: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
     ss = ss_init ();
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     exiting: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
    exiting: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
     dest_state maybe reachable svalues:
      0x3a9f3e0: conjured_svalue (, ss = ss_init ();, decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    entering: get_or_create_node
     point: callstring: [] after SN: 1
     state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}created EN: 7
     point: callstring: [] after SN: 1
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    exiting: get_or_create_node
    creating edge EN: 6 -> EN: 7
   exiting: process_node
   next to process: EN: 7
   peek worklist: EN: 2
   entering: process_node: EN: 7
    point: callstring: [] after SN: 1, state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    considering SN: 1 -> SN: 12 (call)
    entering: on_edge
     entering: on_edge
     exiting: on_edge
     entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
      src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
      dest_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
      uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
      src_state known reachable svalues:
       0x3a9f3e0: conjured_svalue (, ss = ss_init ();, decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
      dest_state maybe reachable svalues:
       0x3a9f3e0: conjured_svalue (, ss = ss_init ();, decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
     exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    exiting: on_edge
    entering: get_or_create_node
     point: callstring: [(SN: 15 -> SN: 2 in main)] before SN: 12 (NULL from-edge) 
     state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}created EN: 8
     point: callstring: [(SN: 15 -> SN: 2 in main)] before SN: 12 (NULL from-edge) 
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    exiting: get_or_create_node
    creating edge EN: 7 -> EN: 8
    considering SN: 1 -> SN: 2 (intraproc link)
    entering: on_edge
     entering: on_edge
      rejecting interprocedural edge
     exiting: on_edge
    exiting: on_edge
    skipping impossible edge to SN: 2
   exiting: process_node
   next to process: EN: 8
   entering: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
   exiting: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
   peek worklist: EN: 2
   entering: process_node: EN: 8
    point: callstring: [(SN: 15 -> SN: 2 in main)] before SN: 12 (NULL from-edge) , state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    entering: get_or_create_node
     point: callstring: [(SN: 15 -> SN: 2 in main)] after SN: 12
     state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}created EN: 9
     point: callstring: [(SN: 15 -> SN: 2 in main)] after SN: 12
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    exiting: get_or_create_node
    creating edge EN: 8 -> EN: 9
   exiting: process_node
   next to process: EN: 9
   peek worklist: EN: 2
   entering: process_node: EN: 9
    point: callstring: [(SN: 15 -> SN: 2 in main)] after SN: 12, state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    considering SN: 12 -> SN: 13 ( (flags FALLTHRU))
    entering: on_edge
     entering: on_edge
     exiting: on_edge
     entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
      src_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
      dest_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
      uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
      src_state known reachable svalues:
       0x3a9f3e0: conjured_svalue (, ss = ss_init ();, decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
      dest_state maybe reachable svalues:
       0x3a9f3e0: conjured_svalue (, ss = ss_init ();, decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
     exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    exiting: on_edge
    entering: get_or_create_node
     point: callstring: [(SN: 15 -> SN: 2 in main)] before SN: 13 (from SN: 12 (bb: 0)) 
     state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}created EN: 10
     point: callstring: [(SN: 15 -> SN: 2 in main)] before SN: 13 (from SN: 12 (bb: 0)) 
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    exiting: get_or_create_node
    creating edge EN: 9 -> EN: 10
   exiting: process_node
   next to process: EN: 10
   entering: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
   exiting: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
   peek worklist: EN: 2
   entering: process_node: EN: 10
    point: callstring: [(SN: 15 -> SN: 2 in main)] before SN: 13 (from SN: 12 (bb: 0)) , state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     dest_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
      0x3a9f3e0: conjured_svalue (, ss = ss_init ();, decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
     dest_state maybe reachable svalues:
      0x3a9f3e0: conjured_svalue (, ss = ss_init ();, decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: get_or_create_node
     point: callstring: [(SN: 15 -> SN: 2 in main)] before (SN: 13 stmt: 0):  rr = {};
     state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}created EN: 11
     point: callstring: [(SN: 15 -> SN: 2 in main)] before (SN: 13 stmt: 0):  rr = {};
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    exiting: get_or_create_node
    creating edge EN: 10 -> EN: 11
   exiting: process_node
   next to process: EN: 11
   peek worklist: EN: 2
   entering: process_node: EN: 11
    point: callstring: [(SN: 15 -> SN: 2 in main)] before (SN: 13 stmt: 0):  rr = {};, state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    entering: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
     rr = {};
    exiting: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     dest_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}clusters within frame: 'ss_init'@2 {, region: {rr, value: CAST(struct ss_s, (char)0)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
      0x3a9f3e0: conjured_svalue (, ss = ss_init ();, decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
     dest_state maybe reachable svalues:
      0x3a9a8c0: constant_svalue('char', 0)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
      0x3a9f3e0: conjured_svalue (, ss = ss_init ();, decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    entering: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
     rr.counting = 1;
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     exiting: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
    exiting: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}clusters within frame: 'ss_init'@2 {, region: {rr, value: CAST(struct ss_s, (char)0)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     dest_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}clusters within frame: 'ss_init'@2 {, base region: {rr} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
      0x3a9a8c0: constant_svalue('char', 0)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
      0x3a9f3e0: conjured_svalue (, ss = ss_init ();, decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
     dest_state maybe reachable svalues:
      0x3a9a8c0: constant_svalue('char', 0)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
      0x3a9f3e0: conjured_svalue (, ss = ss_init ();, decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    entering: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
     D.2757 = rr;
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     exiting: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
    exiting: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}clusters within frame: 'ss_init'@2 {, base region: {rr} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     dest_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}clusters within frame: 'ss_init'@2 {, base region: {rr} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
      0x3a9a8c0: constant_svalue('char', 0)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
      0x3a9f3e0: conjured_svalue (, ss = ss_init ();, decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
     dest_state maybe reachable svalues:
      0x3a9a8c0: constant_svalue('char', 0)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
      0x3a9f3e0: conjured_svalue (, ss = ss_init ();, decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     num_ssas_purged: 0
     num_decl_purged: 1
     entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
      src_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}clusters within frame: 'ss_init'@2 {, base region: {rr} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
      dest_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}clusters within frame: 'ss_init'@2 {, base region: {rr} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
      uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
      src_state known reachable svalues:
       0x3a9a8c0: constant_svalue('char', 0)
       0x3a9c710: constant_svalue('_Bool', 1)
       0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
       0x3a9f3e0: conjured_svalue (, ss = ss_init ();, decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
      dest_state maybe reachable svalues:
       0x3a9a8c0: constant_svalue('char', 0)
       0x3a9c710: constant_svalue('_Bool', 1)
       0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
       0x3a9f3e0: conjured_svalue (, ss = ss_init ();, decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
     exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    entering: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
     rr ={v} {CLOBBER(eol)};
    exiting: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}clusters within frame: 'ss_init'@2 {, base region: {rr} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     dest_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}clusters within frame: 'ss_init'@2 {, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
      0x3a9a8c0: constant_svalue('char', 0)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
      0x3a9f3e0: conjured_svalue (, ss = ss_init ();, decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
     dest_state maybe reachable svalues:
      0x3a9a8c0: constant_svalue('char', 0)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
      0x3a9f3e0: conjured_svalue (, ss = ss_init ();, decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    entering: get_or_create_node
     point: callstring: [(SN: 15 -> SN: 2 in main)] after SN: 13
     state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}clusters within frame: 'ss_init'@2 {, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}clusters within frame: 'ss_init'@2 {, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}clusters within frame: 'ss_init'@2 {, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}created EN: 12
     point: callstring: [(SN: 15 -> SN: 2 in main)] after SN: 13
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}clusters within frame: 'ss_init'@2 {, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    exiting: get_or_create_node
    creating edge EN: 11 -> EN: 12
   exiting: process_node
   next to process: EN: 12
   peek worklist: EN: 2
   entering: process_node: EN: 12
    point: callstring: [(SN: 15 -> SN: 2 in main)] after SN: 13, state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}clusters within frame: 'ss_init'@2 {, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    considering SN: 13 -> SN: 14 ( (flags FALLTHRU))
    entering: on_edge
     entering: on_edge
     exiting: on_edge
     entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
      src_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}clusters within frame: 'ss_init'@2 {, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
      dest_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}clusters within frame: 'ss_init'@2 {, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
      uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
      src_state known reachable svalues:
       0x3a9a8c0: constant_svalue('char', 0)
       0x3a9c710: constant_svalue('_Bool', 1)
       0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
       0x3a9f3e0: conjured_svalue (, ss = ss_init ();, decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
      dest_state maybe reachable svalues:
       0x3a9a8c0: constant_svalue('char', 0)
       0x3a9c710: constant_svalue('_Bool', 1)
       0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
       0x3a9f3e0: conjured_svalue (, ss = ss_init ();, decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
     exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    exiting: on_edge
    entering: get_or_create_node
     point: callstring: [(SN: 15 -> SN: 2 in main)] before SN: 14 (from SN: 13 (bb: 2)) 
     state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}clusters within frame: 'ss_init'@2 {, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}clusters within frame: 'ss_init'@2 {, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}clusters within frame: 'ss_init'@2 {, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}created EN: 13
     point: callstring: [(SN: 15 -> SN: 2 in main)] before SN: 14 (from SN: 13 (bb: 2)) 
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}clusters within frame: 'ss_init'@2 {, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    exiting: get_or_create_node
    creating edge EN: 12 -> EN: 13
   exiting: process_node
   next to process: EN: 13
   entering: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
   exiting: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
   peek worklist: EN: 2
   entering: process_node: EN: 13
    point: callstring: [(SN: 15 -> SN: 2 in main)] before SN: 14 (from SN: 13 (bb: 2)) , state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}clusters within frame: 'ss_init'@2 {, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}clusters within frame: 'ss_init'@2 {, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     dest_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}clusters within frame: 'ss_init'@2 {, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
      0x3a9a8c0: constant_svalue('char', 0)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
      0x3a9f3e0: conjured_svalue (, ss = ss_init ();, decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
     dest_state maybe reachable svalues:
      0x3a9a8c0: constant_svalue('char', 0)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
      0x3a9f3e0: conjured_svalue (, ss = ss_init ();, decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: get_or_create_node
     point: callstring: [(SN: 15 -> SN: 2 in main)] before (SN: 14 stmt: 0):  <L1>:
     state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}clusters within frame: 'ss_init'@2 {, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}clusters within frame: 'ss_init'@2 {, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}clusters within frame: 'ss_init'@2 {, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}created EN: 14
     point: callstring: [(SN: 15 -> SN: 2 in main)] before (SN: 14 stmt: 0):  <L1>:
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}clusters within frame: 'ss_init'@2 {, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    exiting: get_or_create_node
    creating edge EN: 13 -> EN: 14
   exiting: process_node
   next to process: EN: 14
   peek worklist: EN: 2
   entering: process_node: EN: 14
    point: callstring: [(SN: 15 -> SN: 2 in main)] before (SN: 14 stmt: 0):  <L1>:, state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}clusters within frame: 'ss_init'@2 {, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    entering: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
     <L1>:
    exiting: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}clusters within frame: 'ss_init'@2 {, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     dest_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}clusters within frame: 'ss_init'@2 {, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
      0x3a9a8c0: constant_svalue('char', 0)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
      0x3a9f3e0: conjured_svalue (, ss = ss_init ();, decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
     dest_state maybe reachable svalues:
      0x3a9a8c0: constant_svalue('char', 0)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
      0x3a9f3e0: conjured_svalue (, ss = ss_init ();, decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    entering: get_or_create_node
     point: callstring: [(SN: 15 -> SN: 2 in main)] before (SN: 14 stmt: 1):  return D.2757;
     state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}clusters within frame: 'ss_init'@2 {, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}clusters within frame: 'ss_init'@2 {, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}clusters within frame: 'ss_init'@2 {, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}created EN: 15
     point: callstring: [(SN: 15 -> SN: 2 in main)] before (SN: 14 stmt: 1):  return D.2757;
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}clusters within frame: 'ss_init'@2 {, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    exiting: get_or_create_node
    creating edge EN: 14 -> EN: 15
   exiting: process_node
   next to process: EN: 15
   peek worklist: EN: 2
   entering: process_node: EN: 15
    point: callstring: [(SN: 15 -> SN: 2 in main)] before (SN: 14 stmt: 1):  return D.2757;, state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}clusters within frame: 'ss_init'@2 {, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    entering: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
     return D.2757;
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     exiting: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
    exiting: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}clusters within frame: 'ss_init'@2 {, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     dest_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}clusters within frame: 'ss_init'@2 {, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
      0x3a9a8c0: constant_svalue('char', 0)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
      0x3a9f3e0: conjured_svalue (, ss = ss_init ();, decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
     dest_state maybe reachable svalues:
      0x3a9a8c0: constant_svalue('char', 0)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
      0x3a9f3e0: conjured_svalue (, ss = ss_init ();, decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    entering: get_or_create_node
     point: callstring: [(SN: 15 -> SN: 2 in main)] after SN: 14
     state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}clusters within frame: 'ss_init'@2 {, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}clusters within frame: 'ss_init'@2 {, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}clusters within frame: 'ss_init'@2 {, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}created EN: 16
     point: callstring: [(SN: 15 -> SN: 2 in main)] after SN: 14
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}clusters within frame: 'ss_init'@2 {, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    exiting: get_or_create_node
    creating edge EN: 15 -> EN: 16
   exiting: process_node
   next to process: EN: 16
   peek worklist: EN: 2
   entering: process_node: EN: 16
    point: callstring: [(SN: 15 -> SN: 2 in main)] after SN: 14, state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}clusters within frame: 'ss_init'@2 {, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    considering SN: 14 -> SN: 15 ()
    entering: on_edge
     entering: on_edge
     exiting: on_edge
     entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
      src_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}clusters within frame: 'ss_init'@2 {, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
      dest_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}clusters within frame: 'ss_init'@2 {, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
      uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
      src_state known reachable svalues:
       0x3a9a8c0: constant_svalue('char', 0)
       0x3a9c710: constant_svalue('_Bool', 1)
       0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
       0x3a9f3e0: conjured_svalue (, ss = ss_init ();, decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
      dest_state maybe reachable svalues:
       0x3a9a8c0: constant_svalue('char', 0)
       0x3a9c710: constant_svalue('_Bool', 1)
       0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
       0x3a9f3e0: conjured_svalue (, ss = ss_init ();, decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
     exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    exiting: on_edge
    entering: get_or_create_node
     point: callstring: [(SN: 15 -> SN: 2 in main)] before SN: 15 (from SN: 14 (bb: 3)) 
     state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}clusters within frame: 'ss_init'@2 {, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
      num_ssas_purged: 0
      num_decl_purged: 1
      entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
       src_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}clusters within frame: 'ss_init'@2 {, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
       dest_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}clusters within frame: 'ss_init'@2 {, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
       uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
       src_state known reachable svalues:
        0x3a9a8c0: constant_svalue('char', 0)
        0x3a9c710: constant_svalue('_Bool', 1)
        0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
        0x3a9f3e0: conjured_svalue (, ss = ss_init ();, decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
       dest_state maybe reachable svalues:
        0x3a9a8c0: constant_svalue('char', 0)
        0x3a9c710: constant_svalue('_Bool', 1)
        0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
        0x3a9f3e0: conjured_svalue (, ss = ss_init ();, decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
      exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}clusters within frame: 'ss_init'@2 {, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}clusters within frame: 'ss_init'@2 {, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}created EN: 17
     point: callstring: [(SN: 15 -> SN: 2 in main)] before SN: 15 (from SN: 14 (bb: 3)) 
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}clusters within frame: 'ss_init'@2 {, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    exiting: get_or_create_node
    creating edge EN: 16 -> EN: 17
   exiting: process_node
   next to process: EN: 17
   entering: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
   exiting: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
   peek worklist: EN: 2
   entering: process_node: EN: 17
    point: callstring: [(SN: 15 -> SN: 2 in main)] before SN: 15 (from SN: 14 (bb: 3)) , state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}clusters within frame: 'ss_init'@2 {, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}clusters within frame: 'ss_init'@2 {, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     dest_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}clusters within frame: 'ss_init'@2 {, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
      0x3a9a8c0: constant_svalue('char', 0)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
      0x3a9f3e0: conjured_svalue (, ss = ss_init ();, decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
     dest_state maybe reachable svalues:
      0x3a9a8c0: constant_svalue('char', 0)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
      0x3a9f3e0: conjured_svalue (, ss = ss_init ();, decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: get_or_create_node
     point: callstring: [(SN: 15 -> SN: 2 in main)] after SN: 15
     state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}clusters within frame: 'ss_init'@2 {, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
      num_ssas_purged: 0
      num_decl_purged: 1
      entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
       src_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}clusters within frame: 'ss_init'@2 {, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
       dest_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}clusters within frame: 'ss_init'@2 {, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
       uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
       src_state known reachable svalues:
        0x3a9a8c0: constant_svalue('char', 0)
        0x3a9c710: constant_svalue('_Bool', 1)
        0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
        0x3a9f3e0: conjured_svalue (, ss = ss_init ();, decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
       dest_state maybe reachable svalues:
        0x3a9a8c0: constant_svalue('char', 0)
        0x3a9c710: constant_svalue('_Bool', 1)
        0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
        0x3a9f3e0: conjured_svalue (, ss = ss_init ();, decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
      exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}clusters within frame: 'ss_init'@2 {, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}clusters within frame: 'ss_init'@2 {, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}created EN: 18
     point: callstring: [(SN: 15 -> SN: 2 in main)] after SN: 15
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}clusters within frame: 'ss_init'@2 {, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    exiting: get_or_create_node
    creating edge EN: 17 -> EN: 18
   exiting: process_node
   next to process: EN: 18
   peek worklist: EN: 2
   entering: process_node: EN: 18
    point: callstring: [(SN: 15 -> SN: 2 in main)] after SN: 15, state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}clusters within frame: 'ss_init'@2 {, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    entering: detect_leaks: EN: 18
    exiting: detect_leaks
    considering SN: 15 -> SN: 2 (return)
    entering: on_edge
     entering: on_edge
     exiting: on_edge
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     exiting: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
      src_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_init'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {ss, value: CONJURED(ss = ss_init ();, ss)}}clusters within frame: 'ss_init'@2 {, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
      dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
      uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
      src_state known reachable svalues:
       0x3a9a8c0: constant_svalue('char', 0)
       0x3a9c710: constant_svalue('_Bool', 1)
       0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
       0x3a9f3e0: conjured_svalue (, ss = ss_init ();, decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
      dest_state maybe reachable svalues:
       0x3a9a8c0: constant_svalue('char', 0)
       0x3a9c710: constant_svalue('_Bool', 1)
       0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
     exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    exiting: on_edge
    entering: get_or_create_node
     point: callstring: [] before SN: 2 (NULL from-edge) 
     state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}created EN: 19
     point: callstring: [] before SN: 2 (NULL from-edge) 
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    exiting: get_or_create_node
    creating edge EN: 18 -> EN: 19
   exiting: process_node
   next to process: EN: 19
   entering: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
   exiting: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
   peek worklist: EN: 2
   entering: process_node: EN: 19
    point: callstring: [] before SN: 2 (NULL from-edge) , state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    entering: get_or_create_node
     point: callstring: [] before (SN: 2 stmt: 0):  _1 = ss.counting;
     state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}created EN: 20
     point: callstring: [] before (SN: 2 stmt: 0):  _1 = ss.counting;
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    exiting: get_or_create_node
    creating edge EN: 19 -> EN: 20
   exiting: process_node
   next to process: EN: 20
   peek worklist: EN: 2
   entering: process_node: EN: 20
    point: callstring: [] before (SN: 2 stmt: 0):  _1 = ss.counting;, state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    entering: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
     _1 = ss.counting;
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     exiting: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
    exiting: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, region: {_1, value: (_Bool)1}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
      0x3a9a8c0: constant_svalue('char', 0)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
     dest_state maybe reachable svalues:
      0x3a9a8c0: constant_svalue('char', 0)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    entering: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
     _2 = (int) _1;
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     exiting: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
    exiting: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, region: {_1, value: (_Bool)1}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {_2, value: (int)1}, base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, region: {_1, value: (_Bool)1}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
      0x3a9a8c0: constant_svalue('char', 0)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
     dest_state maybe reachable svalues:
      0x3a9a8c0: constant_svalue('char', 0)
      0x3aa7230: constant_svalue('int', 1)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     num_ssas_purged: 1
     num_decl_purged: 0
     entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
      src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {_2, value: (int)1}, base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, region: {_1, value: (_Bool)1}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
      dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {_2, value: (int)1}, base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
      uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
      src_state known reachable svalues:
       0x3a9a8c0: constant_svalue('char', 0)
       0x3aa7230: constant_svalue('int', 1)
       0x3a9c710: constant_svalue('_Bool', 1)
       0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
      dest_state maybe reachable svalues:
       0x3a9a8c0: constant_svalue('char', 0)
       0x3aa7230: constant_svalue('int', 1)
       0x3a9c710: constant_svalue('_Bool', 1)
       0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
     exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    entering: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
     __analyzer_describe (0, _2);
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
    exiting: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {_2, value: (int)1}, base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {_2, value: (int)1}, base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
      0x3a9a8c0: constant_svalue('char', 0)
      0x3aa7230: constant_svalue('int', 1)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
     dest_state maybe reachable svalues:
      0x3a9a8c0: constant_svalue('char', 0)
      0x3aa7230: constant_svalue('int', 1)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     num_ssas_purged: 1
     num_decl_purged: 0
     entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
      src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {_2, value: (int)1}, base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
      dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
      uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
      src_state known reachable svalues:
       0x3a9a8c0: constant_svalue('char', 0)
       0x3aa7230: constant_svalue('int', 1)
       0x3a9c710: constant_svalue('_Bool', 1)
       0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
      dest_state maybe reachable svalues:
       0x3a9a8c0: constant_svalue('char', 0)
       0x3a9c710: constant_svalue('_Bool', 1)
       0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
     exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    entering: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
     ss_out (&ss, 97);
    exiting: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
      0x3a9a8c0: constant_svalue('char', 0)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
     dest_state maybe reachable svalues:
      0x3a9a8c0: constant_svalue('char', 0)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    entering: get_or_create_node
     point: callstring: [] after SN: 2
     state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}created EN: 21
     point: callstring: [] after SN: 2
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    exiting: get_or_create_node
    creating edge EN: 20 -> EN: 21
   exiting: process_node
   next to process: EN: 21
   peek worklist: EN: 2
   entering: process_node: EN: 21
    point: callstring: [] after SN: 2, state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    considering SN: 2 -> SN: 6 (call)
    entering: on_edge
     entering: on_edge
     exiting: on_edge
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     exiting: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     exiting: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
      src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
      dest_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
      uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
      src_state known reachable svalues:
       0x3a9a8c0: constant_svalue('char', 0)
       0x3a9c710: constant_svalue('_Bool', 1)
       0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
      dest_state maybe reachable svalues:
       0x3aa9200: region_svalue('struct ss_s *', decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
       0x3a9a8c0: constant_svalue('char', 0)
       0x3aa9230: constant_svalue('int', 97)
       0x3a9c710: constant_svalue('_Bool', 1)
       0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
     exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    exiting: on_edge
    entering: get_or_create_node
     point: callstring: [(SN: 11 -> SN: 3 in main)] before SN: 6 (NULL from-edge) 
     state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}created EN: 22
     point: callstring: [(SN: 11 -> SN: 3 in main)] before SN: 6 (NULL from-edge) 
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    exiting: get_or_create_node
    creating edge EN: 21 -> EN: 22
    considering SN: 2 -> SN: 3 (intraproc link)
    entering: on_edge
     entering: on_edge
      rejecting interprocedural edge
     exiting: on_edge
    exiting: on_edge
    skipping impossible edge to SN: 3
   exiting: process_node
   next to process: EN: 22
   entering: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
   exiting: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
   peek worklist: EN: 2
   entering: process_node: EN: 22
    point: callstring: [(SN: 11 -> SN: 3 in main)] before SN: 6 (NULL from-edge) , state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    entering: get_or_create_node
     point: callstring: [(SN: 11 -> SN: 3 in main)] after SN: 6
     state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}created EN: 23
     point: callstring: [(SN: 11 -> SN: 3 in main)] after SN: 6
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    exiting: get_or_create_node
    creating edge EN: 22 -> EN: 23
   exiting: process_node
   next to process: EN: 23
   peek worklist: EN: 2
   entering: process_node: EN: 23
    point: callstring: [(SN: 11 -> SN: 3 in main)] after SN: 6, state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    considering SN: 6 -> SN: 7 ( (flags FALLTHRU))
    entering: on_edge
     entering: on_edge
     exiting: on_edge
     entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
      src_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
      dest_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
      uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
      src_state known reachable svalues:
       0x3aa9200: region_svalue('struct ss_s *', decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
       0x3a9a8c0: constant_svalue('char', 0)
       0x3aa9230: constant_svalue('int', 97)
       0x3a9c710: constant_svalue('_Bool', 1)
       0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
      dest_state maybe reachable svalues:
       0x3aa9200: region_svalue('struct ss_s *', decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
       0x3a9a8c0: constant_svalue('char', 0)
       0x3aa9230: constant_svalue('int', 97)
       0x3a9c710: constant_svalue('_Bool', 1)
       0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
     exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    exiting: on_edge
    entering: get_or_create_node
     point: callstring: [(SN: 11 -> SN: 3 in main)] before SN: 7 (from SN: 6 (bb: 0)) 
     state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}created EN: 24
     point: callstring: [(SN: 11 -> SN: 3 in main)] before SN: 7 (from SN: 6 (bb: 0)) 
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    exiting: get_or_create_node
    creating edge EN: 23 -> EN: 24
   exiting: process_node
   next to process: EN: 24
   entering: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
   exiting: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
   peek worklist: EN: 2
   entering: process_node: EN: 24
    point: callstring: [(SN: 11 -> SN: 3 in main)] before SN: 7 (from SN: 6 (bb: 0)) , state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     dest_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
      0x3aa9200: region_svalue('struct ss_s *', decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
      0x3a9a8c0: constant_svalue('char', 0)
      0x3aa9230: constant_svalue('int', 97)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
     dest_state maybe reachable svalues:
      0x3aa9200: region_svalue('struct ss_s *', decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
      0x3a9a8c0: constant_svalue('char', 0)
      0x3aa9230: constant_svalue('int', 97)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: get_or_create_node
     point: callstring: [(SN: 11 -> SN: 3 in main)] before (SN: 7 stmt: 0):  _1 = t_13(D)->counting;
     state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}created EN: 25
     point: callstring: [(SN: 11 -> SN: 3 in main)] before (SN: 7 stmt: 0):  _1 = t_13(D)->counting;
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    exiting: get_or_create_node
    creating edge EN: 24 -> EN: 25
   exiting: process_node
   next to process: EN: 25
   peek worklist: EN: 2
   entering: process_node: EN: 25
    point: callstring: [(SN: 11 -> SN: 3 in main)] before (SN: 7 stmt: 0):  _1 = t_13(D)->counting;, state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    entering: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
     _1 = t_13(D)->counting;
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     exiting: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: get_state
     exiting: get_state
    exiting: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     dest_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_1, value: (_Bool)1}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
      0x3aa9200: region_svalue('struct ss_s *', decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
      0x3a9a8c0: constant_svalue('char', 0)
      0x3aa9230: constant_svalue('int', 97)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
     dest_state maybe reachable svalues:
      0x3aa9200: region_svalue('struct ss_s *', decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
      0x3a9a8c0: constant_svalue('char', 0)
      0x3aa9230: constant_svalue('int', 97)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    entering: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
     _2 = (int) _1;
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     exiting: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
    exiting: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_1, value: (_Bool)1}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
     dest_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_1, value: (_Bool)1}, region: {_2, value: (int)1}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
      0x3aa9200: region_svalue('struct ss_s *', decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
      0x3a9a8c0: constant_svalue('char', 0)
      0x3aa9230: constant_svalue('int', 97)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
     dest_state maybe reachable svalues:
      0x3aa9200: region_svalue('struct ss_s *', decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
      0x3a9a8c0: constant_svalue('char', 0)
      0x3aa7230: constant_svalue('int', 1)
      0x3aa9230: constant_svalue('int', 97)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     num_ssas_purged: 1
     num_decl_purged: 0
     entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
      src_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_1, value: (_Bool)1}, region: {_2, value: (int)1}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
      dest_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_2, value: (int)1}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
      uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
      src_state known reachable svalues:
       0x3aa9200: region_svalue('struct ss_s *', decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
       0x3a9a8c0: constant_svalue('char', 0)
       0x3aa7230: constant_svalue('int', 1)
       0x3aa9230: constant_svalue('int', 97)
       0x3a9c710: constant_svalue('_Bool', 1)
       0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
      dest_state maybe reachable svalues:
       0x3aa9200: region_svalue('struct ss_s *', decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
       0x3a9a8c0: constant_svalue('char', 0)
       0x3aa7230: constant_svalue('int', 1)
       0x3aa9230: constant_svalue('int', 97)
       0x3a9c710: constant_svalue('_Bool', 1)
       0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
     exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    entering: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
     __analyzer_describe (0, _2);
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
    exiting: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_2, value: (int)1}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
     dest_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_2, value: (int)1}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
      0x3aa9200: region_svalue('struct ss_s *', decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
      0x3a9a8c0: constant_svalue('char', 0)
      0x3aa7230: constant_svalue('int', 1)
      0x3aa9230: constant_svalue('int', 97)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
     dest_state maybe reachable svalues:
      0x3aa9200: region_svalue('struct ss_s *', decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
      0x3a9a8c0: constant_svalue('char', 0)
      0x3aa7230: constant_svalue('int', 1)
      0x3aa9230: constant_svalue('int', 97)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     num_ssas_purged: 1
     num_decl_purged: 0
     entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
      src_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_2, value: (int)1}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
      dest_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
      uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
      src_state known reachable svalues:
       0x3aa9200: region_svalue('struct ss_s *', decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
       0x3a9a8c0: constant_svalue('char', 0)
       0x3aa7230: constant_svalue('int', 1)
       0x3aa9230: constant_svalue('int', 97)
       0x3a9c710: constant_svalue('_Bool', 1)
       0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
      dest_state maybe reachable svalues:
       0x3aa9200: region_svalue('struct ss_s *', decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
       0x3a9a8c0: constant_svalue('char', 0)
       0x3aa9230: constant_svalue('int', 97)
       0x3a9c710: constant_svalue('_Bool', 1)
       0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
     exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    entering: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
     _3 = t_13(D)->counting;
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     exiting: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: get_state
     exiting: get_state
    exiting: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
     dest_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_3, value: (_Bool)1}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
      0x3aa9200: region_svalue('struct ss_s *', decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
      0x3a9a8c0: constant_svalue('char', 0)
      0x3aa9230: constant_svalue('int', 97)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
     dest_state maybe reachable svalues:
      0x3aa9200: region_svalue('struct ss_s *', decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
      0x3a9a8c0: constant_svalue('char', 0)
      0x3aa9230: constant_svalue('int', 97)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    entering: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
     _4 = ~_3;
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     exiting: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
    exiting: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_3, value: (_Bool)1}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
     dest_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_3, value: (_Bool)1}, region: {_4, value: (_Bool)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
      0x3aa9200: region_svalue('struct ss_s *', decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
      0x3a9a8c0: constant_svalue('char', 0)
      0x3aa9230: constant_svalue('int', 97)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
     dest_state maybe reachable svalues:
      0x3aa9200: region_svalue('struct ss_s *', decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
      0x3a9a8c0: constant_svalue('char', 0)
      0x3aa9230: constant_svalue('int', 97)
      0x3ab4f30: constant_svalue('_Bool', 0)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     num_ssas_purged: 1
     num_decl_purged: 0
     entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
      src_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_3, value: (_Bool)1}, region: {_4, value: (_Bool)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
      dest_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_4, value: (_Bool)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
      uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
      src_state known reachable svalues:
       0x3aa9200: region_svalue('struct ss_s *', decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
       0x3a9a8c0: constant_svalue('char', 0)
       0x3aa9230: constant_svalue('int', 97)
       0x3ab4f30: constant_svalue('_Bool', 0)
       0x3a9c710: constant_svalue('_Bool', 1)
       0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
      dest_state maybe reachable svalues:
       0x3aa9200: region_svalue('struct ss_s *', decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
       0x3a9a8c0: constant_svalue('char', 0)
       0x3aa9230: constant_svalue('int', 97)
       0x3ab4f30: constant_svalue('_Bool', 0)
       0x3a9c710: constant_svalue('_Bool', 1)
       0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
     exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    entering: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
     _5 = (int) _4;
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     exiting: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
    exiting: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_4, value: (_Bool)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
     dest_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_4, value: (_Bool)0}, region: {_5, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
      0x3aa9200: region_svalue('struct ss_s *', decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
      0x3a9a8c0: constant_svalue('char', 0)
      0x3aa9230: constant_svalue('int', 97)
      0x3ab4f30: constant_svalue('_Bool', 0)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
     dest_state maybe reachable svalues:
      0x3aa9200: region_svalue('struct ss_s *', decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
      0x3a9a8c0: constant_svalue('char', 0)
      0x3ab4ea0: constant_svalue('int', 0)
      0x3aa9230: constant_svalue('int', 97)
      0x3ab4f30: constant_svalue('_Bool', 0)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     num_ssas_purged: 1
     num_decl_purged: 0
     entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
      src_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_4, value: (_Bool)0}, region: {_5, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
      dest_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_5, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
      uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
      src_state known reachable svalues:
       0x3aa9200: region_svalue('struct ss_s *', decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
       0x3a9a8c0: constant_svalue('char', 0)
       0x3ab4ea0: constant_svalue('int', 0)
       0x3aa9230: constant_svalue('int', 97)
       0x3ab4f30: constant_svalue('_Bool', 0)
       0x3a9c710: constant_svalue('_Bool', 1)
       0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
      dest_state maybe reachable svalues:
       0x3aa9200: region_svalue('struct ss_s *', decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
       0x3a9a8c0: constant_svalue('char', 0)
       0x3ab4ea0: constant_svalue('int', 0)
       0x3aa9230: constant_svalue('int', 97)
       0x3a9c710: constant_svalue('_Bool', 1)
       0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
     exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    entering: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
     __analyzer_eval (_5);
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
    exiting: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_5, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
     dest_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_5, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
      0x3aa9200: region_svalue('struct ss_s *', decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
      0x3a9a8c0: constant_svalue('char', 0)
      0x3ab4ea0: constant_svalue('int', 0)
      0x3aa9230: constant_svalue('int', 97)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
     dest_state maybe reachable svalues:
      0x3aa9200: region_svalue('struct ss_s *', decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
      0x3a9a8c0: constant_svalue('char', 0)
      0x3ab4ea0: constant_svalue('int', 0)
      0x3aa9230: constant_svalue('int', 97)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    entering: get_or_create_node
     point: callstring: [(SN: 11 -> SN: 3 in main)] after SN: 7
     state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_5, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_5, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
     stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_5, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}created EN: 26
     point: callstring: [(SN: 11 -> SN: 3 in main)] after SN: 7
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_5, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
    exiting: get_or_create_node
    creating edge EN: 25 -> EN: 26
   exiting: process_node
   next to process: EN: 26
   peek worklist: EN: 2
   entering: process_node: EN: 26
    point: callstring: [(SN: 11 -> SN: 3 in main)] after SN: 7, state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_5, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
    considering SN: 7 -> SN: 16 (call)
    entering: on_edge
     entering: on_edge
     exiting: on_edge
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     exiting: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
      src_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_5, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
      dest_state: {rmodel: {stack depth: 3 {frame (index 2): frame: '__analyzer_eval'@3, frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_5, value: (int)0}}clusters within frame: '__analyzer_eval'@3 {, region: {a, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
      uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
      src_state known reachable svalues:
       0x3aa9200: region_svalue('struct ss_s *', decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
       0x3a9a8c0: constant_svalue('char', 0)
       0x3ab4ea0: constant_svalue('int', 0)
       0x3aa9230: constant_svalue('int', 97)
       0x3a9c710: constant_svalue('_Bool', 1)
       0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
      dest_state maybe reachable svalues:
       0x3aa9200: region_svalue('struct ss_s *', decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
       0x3a9a8c0: constant_svalue('char', 0)
       0x3ab4ea0: constant_svalue('int', 0)
       0x3aa9230: constant_svalue('int', 97)
       0x3a9c710: constant_svalue('_Bool', 1)
       0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
     exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    exiting: on_edge
    entering: get_or_create_node
     point: callstring: [(SN: 11 -> SN: 3 in main), (SN: 18 -> SN: 8 in ss_out)] before SN: 16 (NULL from-edge) 
     state: {rmodel: {stack depth: 3 {frame (index 2): frame: '__analyzer_eval'@3, frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_5, value: (int)0}}clusters within frame: '__analyzer_eval'@3 {, region: {a, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 3 {frame (index 2): frame: '__analyzer_eval'@3, frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_5, value: (int)0}}clusters within frame: '__analyzer_eval'@3 {, region: {a, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
     stack depth: 3 {frame (index 2): frame: '__analyzer_eval'@3, frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_5, value: (int)0}}clusters within frame: '__analyzer_eval'@3 {, region: {a, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}created EN: 27
     point: callstring: [(SN: 11 -> SN: 3 in main), (SN: 18 -> SN: 8 in ss_out)] before SN: 16 (NULL from-edge) 
     pruned_state: {rmodel: {stack depth: 3 {frame (index 2): frame: '__analyzer_eval'@3, frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_5, value: (int)0}}clusters within frame: '__analyzer_eval'@3 {, region: {a, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
    exiting: get_or_create_node
    creating edge EN: 26 -> EN: 27
    considering SN: 7 -> SN: 8 (intraproc link)
    entering: on_edge
     entering: on_edge
      rejecting interprocedural edge
     exiting: on_edge
    exiting: on_edge
    skipping impossible edge to SN: 8
   exiting: process_node
   next to process: EN: 27
   entering: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
   exiting: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
   peek worklist: EN: 2
   entering: process_node: EN: 27
    point: callstring: [(SN: 11 -> SN: 3 in main), (SN: 18 -> SN: 8 in ss_out)] before SN: 16 (NULL from-edge) , state: {rmodel: {stack depth: 3 {frame (index 2): frame: '__analyzer_eval'@3, frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_5, value: (int)0}}clusters within frame: '__analyzer_eval'@3 {, region: {a, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
    entering: get_or_create_node
     point: callstring: [(SN: 11 -> SN: 3 in main), (SN: 18 -> SN: 8 in ss_out)] after SN: 16
     state: {rmodel: {stack depth: 3 {frame (index 2): frame: '__analyzer_eval'@3, frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_5, value: (int)0}}clusters within frame: '__analyzer_eval'@3 {, region: {a, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 3 {frame (index 2): frame: '__analyzer_eval'@3, frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_5, value: (int)0}}clusters within frame: '__analyzer_eval'@3 {, region: {a, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
     stack depth: 3 {frame (index 2): frame: '__analyzer_eval'@3, frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_5, value: (int)0}}clusters within frame: '__analyzer_eval'@3 {, region: {a, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}created EN: 28
     point: callstring: [(SN: 11 -> SN: 3 in main), (SN: 18 -> SN: 8 in ss_out)] after SN: 16
     pruned_state: {rmodel: {stack depth: 3 {frame (index 2): frame: '__analyzer_eval'@3, frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_5, value: (int)0}}clusters within frame: '__analyzer_eval'@3 {, region: {a, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
    exiting: get_or_create_node
    creating edge EN: 27 -> EN: 28
   exiting: process_node
   next to process: EN: 28
   peek worklist: EN: 2
   entering: process_node: EN: 28
    point: callstring: [(SN: 11 -> SN: 3 in main), (SN: 18 -> SN: 8 in ss_out)] after SN: 16, state: {rmodel: {stack depth: 3 {frame (index 2): frame: '__analyzer_eval'@3, frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_5, value: (int)0}}clusters within frame: '__analyzer_eval'@3 {, region: {a, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
    considering SN: 16 -> SN: 17 ( (flags FALLTHRU))
    entering: on_edge
     entering: on_edge
     exiting: on_edge
     entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
      src_state: {rmodel: {stack depth: 3 {frame (index 2): frame: '__analyzer_eval'@3, frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_5, value: (int)0}}clusters within frame: '__analyzer_eval'@3 {, region: {a, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
      dest_state: {rmodel: {stack depth: 3 {frame (index 2): frame: '__analyzer_eval'@3, frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_5, value: (int)0}}clusters within frame: '__analyzer_eval'@3 {, region: {a, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
      uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
      src_state known reachable svalues:
       0x3aa9200: region_svalue('struct ss_s *', decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
       0x3a9a8c0: constant_svalue('char', 0)
       0x3ab4ea0: constant_svalue('int', 0)
       0x3aa9230: constant_svalue('int', 97)
       0x3a9c710: constant_svalue('_Bool', 1)
       0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
      dest_state maybe reachable svalues:
       0x3aa9200: region_svalue('struct ss_s *', decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
       0x3a9a8c0: constant_svalue('char', 0)
       0x3ab4ea0: constant_svalue('int', 0)
       0x3aa9230: constant_svalue('int', 97)
       0x3a9c710: constant_svalue('_Bool', 1)
       0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
     exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    exiting: on_edge
    entering: get_or_create_node
     point: callstring: [(SN: 11 -> SN: 3 in main), (SN: 18 -> SN: 8 in ss_out)] before SN: 17 (from SN: 16 (bb: 0)) 
     state: {rmodel: {stack depth: 3 {frame (index 2): frame: '__analyzer_eval'@3, frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_5, value: (int)0}}clusters within frame: '__analyzer_eval'@3 {, region: {a, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 3 {frame (index 2): frame: '__analyzer_eval'@3, frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_5, value: (int)0}}clusters within frame: '__analyzer_eval'@3 {, region: {a, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
     stack depth: 3 {frame (index 2): frame: '__analyzer_eval'@3, frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_5, value: (int)0}}clusters within frame: '__analyzer_eval'@3 {, region: {a, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}created EN: 29
     point: callstring: [(SN: 11 -> SN: 3 in main), (SN: 18 -> SN: 8 in ss_out)] before SN: 17 (from SN: 16 (bb: 0)) 
     pruned_state: {rmodel: {stack depth: 3 {frame (index 2): frame: '__analyzer_eval'@3, frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_5, value: (int)0}}clusters within frame: '__analyzer_eval'@3 {, region: {a, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
    exiting: get_or_create_node
    creating edge EN: 28 -> EN: 29
   exiting: process_node
   next to process: EN: 29
   entering: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
   exiting: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
   peek worklist: EN: 2
   entering: process_node: EN: 29
    point: callstring: [(SN: 11 -> SN: 3 in main), (SN: 18 -> SN: 8 in ss_out)] before SN: 17 (from SN: 16 (bb: 0)) , state: {rmodel: {stack depth: 3 {frame (index 2): frame: '__analyzer_eval'@3, frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_5, value: (int)0}}clusters within frame: '__analyzer_eval'@3 {, region: {a, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 3 {frame (index 2): frame: '__analyzer_eval'@3, frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_5, value: (int)0}}clusters within frame: '__analyzer_eval'@3 {, region: {a, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
     dest_state: {rmodel: {stack depth: 3 {frame (index 2): frame: '__analyzer_eval'@3, frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_5, value: (int)0}}clusters within frame: '__analyzer_eval'@3 {, region: {a, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
      0x3aa9200: region_svalue('struct ss_s *', decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
      0x3a9a8c0: constant_svalue('char', 0)
      0x3ab4ea0: constant_svalue('int', 0)
      0x3aa9230: constant_svalue('int', 97)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
     dest_state maybe reachable svalues:
      0x3aa9200: region_svalue('struct ss_s *', decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
      0x3a9a8c0: constant_svalue('char', 0)
      0x3ab4ea0: constant_svalue('int', 0)
      0x3aa9230: constant_svalue('int', 97)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: get_or_create_node
     point: callstring: [(SN: 11 -> SN: 3 in main), (SN: 18 -> SN: 8 in ss_out)] before (SN: 17 stmt: 0):  return;
     state: {rmodel: {stack depth: 3 {frame (index 2): frame: '__analyzer_eval'@3, frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_5, value: (int)0}}clusters within frame: '__analyzer_eval'@3 {, region: {a, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 3 {frame (index 2): frame: '__analyzer_eval'@3, frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_5, value: (int)0}}clusters within frame: '__analyzer_eval'@3 {, region: {a, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
     stack depth: 3 {frame (index 2): frame: '__analyzer_eval'@3, frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_5, value: (int)0}}clusters within frame: '__analyzer_eval'@3 {, region: {a, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}created EN: 30
     point: callstring: [(SN: 11 -> SN: 3 in main), (SN: 18 -> SN: 8 in ss_out)] before (SN: 17 stmt: 0):  return;
     pruned_state: {rmodel: {stack depth: 3 {frame (index 2): frame: '__analyzer_eval'@3, frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_5, value: (int)0}}clusters within frame: '__analyzer_eval'@3 {, region: {a, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
    exiting: get_or_create_node
    creating edge EN: 29 -> EN: 30
   exiting: process_node
   next to process: EN: 30
   peek worklist: EN: 2
   entering: process_node: EN: 30
    point: callstring: [(SN: 11 -> SN: 3 in main), (SN: 18 -> SN: 8 in ss_out)] before (SN: 17 stmt: 0):  return;, state: {rmodel: {stack depth: 3 {frame (index 2): frame: '__analyzer_eval'@3, frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_5, value: (int)0}}clusters within frame: '__analyzer_eval'@3 {, region: {a, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
    entering: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
     return;
    exiting: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 3 {frame (index 2): frame: '__analyzer_eval'@3, frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_5, value: (int)0}}clusters within frame: '__analyzer_eval'@3 {, region: {a, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
     dest_state: {rmodel: {stack depth: 3 {frame (index 2): frame: '__analyzer_eval'@3, frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_5, value: (int)0}}clusters within frame: '__analyzer_eval'@3 {, region: {a, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
      0x3aa9200: region_svalue('struct ss_s *', decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
      0x3a9a8c0: constant_svalue('char', 0)
      0x3ab4ea0: constant_svalue('int', 0)
      0x3aa9230: constant_svalue('int', 97)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
     dest_state maybe reachable svalues:
      0x3aa9200: region_svalue('struct ss_s *', decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
      0x3a9a8c0: constant_svalue('char', 0)
      0x3ab4ea0: constant_svalue('int', 0)
      0x3aa9230: constant_svalue('int', 97)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    entering: get_or_create_node
     point: callstring: [(SN: 11 -> SN: 3 in main), (SN: 18 -> SN: 8 in ss_out)] after SN: 17
     state: {rmodel: {stack depth: 3 {frame (index 2): frame: '__analyzer_eval'@3, frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_5, value: (int)0}}clusters within frame: '__analyzer_eval'@3 {, region: {a, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 3 {frame (index 2): frame: '__analyzer_eval'@3, frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_5, value: (int)0}}clusters within frame: '__analyzer_eval'@3 {, region: {a, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
     stack depth: 3 {frame (index 2): frame: '__analyzer_eval'@3, frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_5, value: (int)0}}clusters within frame: '__analyzer_eval'@3 {, region: {a, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}created EN: 31
     point: callstring: [(SN: 11 -> SN: 3 in main), (SN: 18 -> SN: 8 in ss_out)] after SN: 17
     pruned_state: {rmodel: {stack depth: 3 {frame (index 2): frame: '__analyzer_eval'@3, frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_5, value: (int)0}}clusters within frame: '__analyzer_eval'@3 {, region: {a, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
    exiting: get_or_create_node
    creating edge EN: 30 -> EN: 31
   exiting: process_node
   next to process: EN: 31
   peek worklist: EN: 2
   entering: process_node: EN: 31
    point: callstring: [(SN: 11 -> SN: 3 in main), (SN: 18 -> SN: 8 in ss_out)] after SN: 17, state: {rmodel: {stack depth: 3 {frame (index 2): frame: '__analyzer_eval'@3, frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_5, value: (int)0}}clusters within frame: '__analyzer_eval'@3 {, region: {a, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
    considering SN: 17 -> SN: 18 ()
    entering: on_edge
     entering: on_edge
     exiting: on_edge
     entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
      src_state: {rmodel: {stack depth: 3 {frame (index 2): frame: '__analyzer_eval'@3, frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_5, value: (int)0}}clusters within frame: '__analyzer_eval'@3 {, region: {a, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
      dest_state: {rmodel: {stack depth: 3 {frame (index 2): frame: '__analyzer_eval'@3, frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_5, value: (int)0}}clusters within frame: '__analyzer_eval'@3 {, region: {a, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
      uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
      src_state known reachable svalues:
       0x3aa9200: region_svalue('struct ss_s *', decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
       0x3a9a8c0: constant_svalue('char', 0)
       0x3ab4ea0: constant_svalue('int', 0)
       0x3aa9230: constant_svalue('int', 97)
       0x3a9c710: constant_svalue('_Bool', 1)
       0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
      dest_state maybe reachable svalues:
       0x3aa9200: region_svalue('struct ss_s *', decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
       0x3a9a8c0: constant_svalue('char', 0)
       0x3ab4ea0: constant_svalue('int', 0)
       0x3aa9230: constant_svalue('int', 97)
       0x3a9c710: constant_svalue('_Bool', 1)
       0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
     exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    exiting: on_edge
    entering: get_or_create_node
     point: callstring: [(SN: 11 -> SN: 3 in main), (SN: 18 -> SN: 8 in ss_out)] before SN: 18 (from SN: 17 (bb: 2)) 
     state: {rmodel: {stack depth: 3 {frame (index 2): frame: '__analyzer_eval'@3, frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_5, value: (int)0}}clusters within frame: '__analyzer_eval'@3 {, region: {a, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 3 {frame (index 2): frame: '__analyzer_eval'@3, frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_5, value: (int)0}}clusters within frame: '__analyzer_eval'@3 {, region: {a, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
     stack depth: 3 {frame (index 2): frame: '__analyzer_eval'@3, frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_5, value: (int)0}}clusters within frame: '__analyzer_eval'@3 {, region: {a, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}created EN: 32
     point: callstring: [(SN: 11 -> SN: 3 in main), (SN: 18 -> SN: 8 in ss_out)] before SN: 18 (from SN: 17 (bb: 2)) 
     pruned_state: {rmodel: {stack depth: 3 {frame (index 2): frame: '__analyzer_eval'@3, frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_5, value: (int)0}}clusters within frame: '__analyzer_eval'@3 {, region: {a, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
    exiting: get_or_create_node
    creating edge EN: 31 -> EN: 32
   exiting: process_node
   next to process: EN: 32
   entering: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
   exiting: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
   peek worklist: EN: 2
   entering: process_node: EN: 32
    point: callstring: [(SN: 11 -> SN: 3 in main), (SN: 18 -> SN: 8 in ss_out)] before SN: 18 (from SN: 17 (bb: 2)) , state: {rmodel: {stack depth: 3 {frame (index 2): frame: '__analyzer_eval'@3, frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_5, value: (int)0}}clusters within frame: '__analyzer_eval'@3 {, region: {a, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 3 {frame (index 2): frame: '__analyzer_eval'@3, frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_5, value: (int)0}}clusters within frame: '__analyzer_eval'@3 {, region: {a, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
     dest_state: {rmodel: {stack depth: 3 {frame (index 2): frame: '__analyzer_eval'@3, frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_5, value: (int)0}}clusters within frame: '__analyzer_eval'@3 {, region: {a, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
      0x3aa9200: region_svalue('struct ss_s *', decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
      0x3a9a8c0: constant_svalue('char', 0)
      0x3ab4ea0: constant_svalue('int', 0)
      0x3aa9230: constant_svalue('int', 97)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
     dest_state maybe reachable svalues:
      0x3aa9200: region_svalue('struct ss_s *', decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
      0x3a9a8c0: constant_svalue('char', 0)
      0x3ab4ea0: constant_svalue('int', 0)
      0x3aa9230: constant_svalue('int', 97)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: get_or_create_node
     point: callstring: [(SN: 11 -> SN: 3 in main), (SN: 18 -> SN: 8 in ss_out)] after SN: 18
     state: {rmodel: {stack depth: 3 {frame (index 2): frame: '__analyzer_eval'@3, frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_5, value: (int)0}}clusters within frame: '__analyzer_eval'@3 {, region: {a, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 3 {frame (index 2): frame: '__analyzer_eval'@3, frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_5, value: (int)0}}clusters within frame: '__analyzer_eval'@3 {, region: {a, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
     stack depth: 3 {frame (index 2): frame: '__analyzer_eval'@3, frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_5, value: (int)0}}clusters within frame: '__analyzer_eval'@3 {, region: {a, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}created EN: 33
     point: callstring: [(SN: 11 -> SN: 3 in main), (SN: 18 -> SN: 8 in ss_out)] after SN: 18
     pruned_state: {rmodel: {stack depth: 3 {frame (index 2): frame: '__analyzer_eval'@3, frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_5, value: (int)0}}clusters within frame: '__analyzer_eval'@3 {, region: {a, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
    exiting: get_or_create_node
    creating edge EN: 32 -> EN: 33
   exiting: process_node
   next to process: EN: 33
   peek worklist: EN: 2
   entering: process_node: EN: 33
    point: callstring: [(SN: 11 -> SN: 3 in main), (SN: 18 -> SN: 8 in ss_out)] after SN: 18, state: {rmodel: {stack depth: 3 {frame (index 2): frame: '__analyzer_eval'@3, frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_5, value: (int)0}}clusters within frame: '__analyzer_eval'@3 {, region: {a, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
    entering: detect_leaks: EN: 33
    exiting: detect_leaks
    considering SN: 18 -> SN: 8 (return)
    entering: on_edge
     entering: on_edge
     exiting: on_edge
     entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
      src_state: {rmodel: {stack depth: 3 {frame (index 2): frame: '__analyzer_eval'@3, frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_5, value: (int)0}}clusters within frame: '__analyzer_eval'@3 {, region: {a, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
      dest_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_5, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
      uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
      src_state known reachable svalues:
       0x3aa9200: region_svalue('struct ss_s *', decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
       0x3a9a8c0: constant_svalue('char', 0)
       0x3ab4ea0: constant_svalue('int', 0)
       0x3aa9230: constant_svalue('int', 97)
       0x3a9c710: constant_svalue('_Bool', 1)
       0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
      dest_state maybe reachable svalues:
       0x3aa9200: region_svalue('struct ss_s *', decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
       0x3a9a8c0: constant_svalue('char', 0)
       0x3ab4ea0: constant_svalue('int', 0)
       0x3aa9230: constant_svalue('int', 97)
       0x3a9c710: constant_svalue('_Bool', 1)
       0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
     exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    exiting: on_edge
    entering: get_or_create_node
     point: callstring: [(SN: 11 -> SN: 3 in main)] before SN: 8 (NULL from-edge) 
     state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_5, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
      num_ssas_purged: 1
      num_decl_purged: 0
      entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
       src_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_5, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
       dest_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
       uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
       src_state known reachable svalues:
        0x3aa9200: region_svalue('struct ss_s *', decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
        0x3a9a8c0: constant_svalue('char', 0)
        0x3ab4ea0: constant_svalue('int', 0)
        0x3aa9230: constant_svalue('int', 97)
        0x3a9c710: constant_svalue('_Bool', 1)
        0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
       dest_state maybe reachable svalues:
        0x3aa9200: region_svalue('struct ss_s *', decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
        0x3a9a8c0: constant_svalue('char', 0)
        0x3aa9230: constant_svalue('int', 97)
        0x3a9c710: constant_svalue('_Bool', 1)
        0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
      exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
     stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}created EN: 34
     point: callstring: [(SN: 11 -> SN: 3 in main)] before SN: 8 (NULL from-edge) 
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
    exiting: get_or_create_node
    creating edge EN: 33 -> EN: 34
   exiting: process_node
   next to process: EN: 34
   entering: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
   exiting: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
   peek worklist: EN: 2
   entering: process_node: EN: 34
    point: callstring: [(SN: 11 -> SN: 3 in main)] before SN: 8 (NULL from-edge) , state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
    entering: get_or_create_node
     point: callstring: [(SN: 11 -> SN: 3 in main)] before (SN: 8 stmt: 0):  _6 = t_13(D)->counting;
     state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
     stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}created EN: 35
     point: callstring: [(SN: 11 -> SN: 3 in main)] before (SN: 8 stmt: 0):  _6 = t_13(D)->counting;
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
    exiting: get_or_create_node
    creating edge EN: 34 -> EN: 35
   exiting: process_node
   next to process: EN: 35
   peek worklist: EN: 2
   entering: process_node: EN: 35
    point: callstring: [(SN: 11 -> SN: 3 in main)] before (SN: 8 stmt: 0):  _6 = t_13(D)->counting;, state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
    entering: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
     _6 = t_13(D)->counting;
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     exiting: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: get_state
     exiting: get_state
    exiting: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
     dest_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_6, value: (_Bool)1}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
      0x3aa9200: region_svalue('struct ss_s *', decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
      0x3a9a8c0: constant_svalue('char', 0)
      0x3aa9230: constant_svalue('int', 97)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
     dest_state maybe reachable svalues:
      0x3aa9200: region_svalue('struct ss_s *', decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
      0x3a9a8c0: constant_svalue('char', 0)
      0x3aa9230: constant_svalue('int', 97)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    entering: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
     _7 = ~_6;
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     exiting: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
    exiting: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_6, value: (_Bool)1}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
     dest_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_6, value: (_Bool)1}, region: {_7, value: (_Bool)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
      0x3aa9200: region_svalue('struct ss_s *', decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
      0x3a9a8c0: constant_svalue('char', 0)
      0x3aa9230: constant_svalue('int', 97)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
     dest_state maybe reachable svalues:
      0x3aa9200: region_svalue('struct ss_s *', decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
      0x3a9a8c0: constant_svalue('char', 0)
      0x3aa9230: constant_svalue('int', 97)
      0x3ab4f30: constant_svalue('_Bool', 0)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     num_ssas_purged: 1
     num_decl_purged: 0
     entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
      src_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_6, value: (_Bool)1}, region: {_7, value: (_Bool)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
      dest_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_7, value: (_Bool)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
      uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
      src_state known reachable svalues:
       0x3aa9200: region_svalue('struct ss_s *', decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
       0x3a9a8c0: constant_svalue('char', 0)
       0x3aa9230: constant_svalue('int', 97)
       0x3ab4f30: constant_svalue('_Bool', 0)
       0x3a9c710: constant_svalue('_Bool', 1)
       0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
      dest_state maybe reachable svalues:
       0x3aa9200: region_svalue('struct ss_s *', decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
       0x3a9a8c0: constant_svalue('char', 0)
       0x3aa9230: constant_svalue('int', 97)
       0x3ab4f30: constant_svalue('_Bool', 0)
       0x3a9c710: constant_svalue('_Bool', 1)
       0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
     exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    entering: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
     if (_7 != 0)
    exiting: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_7, value: (_Bool)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
     dest_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_7, value: (_Bool)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
      0x3aa9200: region_svalue('struct ss_s *', decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
      0x3a9a8c0: constant_svalue('char', 0)
      0x3aa9230: constant_svalue('int', 97)
      0x3ab4f30: constant_svalue('_Bool', 0)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
     dest_state maybe reachable svalues:
      0x3aa9200: region_svalue('struct ss_s *', decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
      0x3a9a8c0: constant_svalue('char', 0)
      0x3aa9230: constant_svalue('int', 97)
      0x3ab4f30: constant_svalue('_Bool', 0)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    entering: get_or_create_node
     point: callstring: [(SN: 11 -> SN: 3 in main)] after SN: 8
     state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_7, value: (_Bool)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_7, value: (_Bool)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
     stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_7, value: (_Bool)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}created EN: 36
     point: callstring: [(SN: 11 -> SN: 3 in main)] after SN: 8
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_7, value: (_Bool)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
    exiting: get_or_create_node
    creating edge EN: 35 -> EN: 36
   exiting: process_node
   next to process: EN: 36
   peek worklist: EN: 2
   entering: process_node: EN: 36
    point: callstring: [(SN: 11 -> SN: 3 in main)] after SN: 8, state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_7, value: (_Bool)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
    considering SN: 8 -> SN: 9 (true (flags TRUE_VALUE))
    entering: on_edge
     entering: on_edge
     exiting: on_edge
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     edge to SN: 9 is impossible due to region_model constraints
    exiting: on_edge
    skipping impossible edge to SN: 9
    considering SN: 8 -> SN: 10 (false (flags FALSE_VALUE))
    entering: on_edge
     entering: on_edge
     exiting: on_edge
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
      src_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_7, value: (_Bool)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
      dest_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_7, value: (_Bool)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
      uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
      src_state known reachable svalues:
       0x3aa9200: region_svalue('struct ss_s *', decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
       0x3a9a8c0: constant_svalue('char', 0)
       0x3aa9230: constant_svalue('int', 97)
       0x3ab4f30: constant_svalue('_Bool', 0)
       0x3a9c710: constant_svalue('_Bool', 1)
       0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
      dest_state maybe reachable svalues:
       0x3aa9200: region_svalue('struct ss_s *', decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
       0x3a9a8c0: constant_svalue('char', 0)
       0x3aa9230: constant_svalue('int', 97)
       0x3ab4f30: constant_svalue('_Bool', 0)
       0x3a9c710: constant_svalue('_Bool', 1)
       0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
     exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    exiting: on_edge
    entering: get_or_create_node
     point: callstring: [(SN: 11 -> SN: 3 in main)] before SN: 10 (from SN: 8 (bb: 2)) .MEM_11 = PHI <.MEM_15(2), .MEM_18(3)>
     state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_7, value: (_Bool)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
      num_ssas_purged: 3
      num_decl_purged: 0
      entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
       src_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}clusters within frame: 'ss_out'@2 {, region: {t_13(D), value: &ss}, region: {cc_17(D), value: (int)97}, region: {_7, value: (_Bool)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
       dest_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {&ss}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {&ss} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
       uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
       src_state known reachable svalues:
        0x3aa9200: region_svalue('struct ss_s *', decl_region(frame_region('main', index: 0, depth: 1), 'struct ss_s', 'ss'))
        0x3a9a8c0: constant_svalue('char', 0)
        0x3aa9230: constant_svalue('int', 97)
        0x3ab4f30: constant_svalue('_Bool', 0)
        0x3a9c710: constant_svalue('_Bool', 1)
        0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
       dest_state maybe reachable svalues:
        0x3a9a8c0: constant_svalue('char', 0)
        0x3a9c710: constant_svalue('_Bool', 1)
        0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
      exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}created EN: 37
     point: callstring: [(SN: 11 -> SN: 3 in main)] before SN: 10 (from SN: 8 (bb: 2)) .MEM_11 = PHI <.MEM_15(2), .MEM_18(3)>
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    exiting: get_or_create_node
    creating edge EN: 36 -> EN: 37
   exiting: process_node
   next to process: EN: 37
   entering: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
   exiting: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
   peek worklist: EN: 2
   entering: process_node: EN: 37
    point: callstring: [(SN: 11 -> SN: 3 in main)] before SN: 10 (from SN: 8 (bb: 2)) .MEM_11 = PHI <.MEM_15(2), .MEM_18(3)>, state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     dest_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
      0x3a9a8c0: constant_svalue('char', 0)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
     dest_state maybe reachable svalues:
      0x3a9a8c0: constant_svalue('char', 0)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: get_or_create_node
     point: callstring: [(SN: 11 -> SN: 3 in main)] before (SN: 10 stmt: 0):  return;
     state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}created EN: 38
     point: callstring: [(SN: 11 -> SN: 3 in main)] before (SN: 10 stmt: 0):  return;
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    exiting: get_or_create_node
    creating edge EN: 37 -> EN: 38
   exiting: process_node
   next to process: EN: 38
   peek worklist: EN: 2
   entering: process_node: EN: 38
    point: callstring: [(SN: 11 -> SN: 3 in main)] before (SN: 10 stmt: 0):  return;, state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    entering: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
     return;
    exiting: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     dest_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
      0x3a9a8c0: constant_svalue('char', 0)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
     dest_state maybe reachable svalues:
      0x3a9a8c0: constant_svalue('char', 0)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    entering: get_or_create_node
     point: callstring: [(SN: 11 -> SN: 3 in main)] after SN: 10
     state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}created EN: 39
     point: callstring: [(SN: 11 -> SN: 3 in main)] after SN: 10
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    exiting: get_or_create_node
    creating edge EN: 38 -> EN: 39
   exiting: process_node
   next to process: EN: 39
   peek worklist: EN: 2
   entering: process_node: EN: 39
    point: callstring: [(SN: 11 -> SN: 3 in main)] after SN: 10, state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    considering SN: 10 -> SN: 11 ()
    entering: on_edge
     entering: on_edge
     exiting: on_edge
     entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
      src_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
      dest_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
      uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
      src_state known reachable svalues:
       0x3a9a8c0: constant_svalue('char', 0)
       0x3a9c710: constant_svalue('_Bool', 1)
       0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
      dest_state maybe reachable svalues:
       0x3a9a8c0: constant_svalue('char', 0)
       0x3a9c710: constant_svalue('_Bool', 1)
       0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
     exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    exiting: on_edge
    entering: get_or_create_node
     point: callstring: [(SN: 11 -> SN: 3 in main)] before SN: 11 (from SN: 10 (bb: 4)) 
     state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}created EN: 40
     point: callstring: [(SN: 11 -> SN: 3 in main)] before SN: 11 (from SN: 10 (bb: 4)) 
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    exiting: get_or_create_node
    creating edge EN: 39 -> EN: 40
   exiting: process_node
   next to process: EN: 40
   entering: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
   exiting: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
   peek worklist: EN: 2
   entering: process_node: EN: 40
    point: callstring: [(SN: 11 -> SN: 3 in main)] before SN: 11 (from SN: 10 (bb: 4)) , state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     dest_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
      0x3a9a8c0: constant_svalue('char', 0)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
     dest_state maybe reachable svalues:
      0x3a9a8c0: constant_svalue('char', 0)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: get_or_create_node
     point: callstring: [(SN: 11 -> SN: 3 in main)] after SN: 11
     state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}created EN: 41
     point: callstring: [(SN: 11 -> SN: 3 in main)] after SN: 11
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    exiting: get_or_create_node
    creating edge EN: 40 -> EN: 41
   exiting: process_node
   next to process: EN: 41
   peek worklist: EN: 2
   entering: process_node: EN: 41
    point: callstring: [(SN: 11 -> SN: 3 in main)] after SN: 11, state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    entering: detect_leaks: EN: 41
    exiting: detect_leaks
    considering SN: 11 -> SN: 3 (return)
    entering: on_edge
     entering: on_edge
     exiting: on_edge
     entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
      src_state: {rmodel: {stack depth: 2 {frame (index 1): frame: 'ss_out'@2, frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
      dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
      uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
      src_state known reachable svalues:
       0x3a9a8c0: constant_svalue('char', 0)
       0x3a9c710: constant_svalue('_Bool', 1)
       0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
      dest_state maybe reachable svalues:
       0x3a9a8c0: constant_svalue('char', 0)
       0x3a9c710: constant_svalue('_Bool', 1)
       0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
     exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    exiting: on_edge
    entering: get_or_create_node
     point: callstring: [] before SN: 3 (NULL from-edge) 
     state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}created EN: 42
     point: callstring: [] before SN: 3 (NULL from-edge) 
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    exiting: get_or_create_node
    creating edge EN: 41 -> EN: 42
   exiting: process_node
   next to process: EN: 42
   entering: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
   exiting: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
   peek worklist: EN: 2
   entering: process_node: EN: 42
    point: callstring: [] before SN: 3 (NULL from-edge) , state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    entering: get_or_create_node
     point: callstring: [] before (SN: 3 stmt: 0):  ss ={v} {CLOBBER(eol)};
     state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}created EN: 43
     point: callstring: [] before (SN: 3 stmt: 0):  ss ={v} {CLOBBER(eol)};
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    exiting: get_or_create_node
    creating edge EN: 42 -> EN: 43
   exiting: process_node
   next to process: EN: 43
   peek worklist: EN: 2
   entering: process_node: EN: 43
    point: callstring: [] before (SN: 3 stmt: 0):  ss ={v} {CLOBBER(eol)};, state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    entering: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
     ss ={v} {CLOBBER(eol)};
    exiting: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {base region: {ss} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
      0x3a9a8c0: constant_svalue('char', 0)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
     dest_state maybe reachable svalues:
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    entering: get_or_create_node
     point: callstring: [] before (SN: 3 stmt: 1):  _8 = 0;
     state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     stack depth: 1 {frame (index 0): frame: 'main'@1}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}created EN: 44
     point: callstring: [] before (SN: 3 stmt: 1):  _8 = 0;
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    exiting: get_or_create_node
    creating edge EN: 43 -> EN: 44
   exiting: process_node
   next to process: EN: 44
   peek worklist: EN: 2
   entering: process_node: EN: 44
    point: callstring: [] before (SN: 3 stmt: 1):  _8 = 0;, state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    entering: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
     _8 = 0;
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     exiting: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
    exiting: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {_8, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
     dest_state maybe reachable svalues:
      0x3ab4ea0: constant_svalue('int', 0)
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    entering: get_or_create_node
     point: callstring: [] after SN: 3
     state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {_8, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {_8, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {_8, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}created EN: 45
     point: callstring: [] after SN: 3
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {_8, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    exiting: get_or_create_node
    creating edge EN: 44 -> EN: 45
   exiting: process_node
   next to process: EN: 45
   peek worklist: EN: 2
   entering: process_node: EN: 45
    point: callstring: [] after SN: 3, state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {_8, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    considering SN: 3 -> SN: 4 ( (flags FALLTHRU))
    entering: on_edge
     entering: on_edge
     exiting: on_edge
     entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
      src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {_8, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
      dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {_8, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
      uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
      src_state known reachable svalues:
       0x3ab4ea0: constant_svalue('int', 0)
      dest_state maybe reachable svalues:
       0x3ab4ea0: constant_svalue('int', 0)
     exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    exiting: on_edge
    entering: get_or_create_node
     point: callstring: [] before SN: 4 (from SN: 3 (bb: 2)) 
     state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {_8, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {_8, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {_8, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}created EN: 46
     point: callstring: [] before SN: 4 (from SN: 3 (bb: 2)) 
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {_8, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    exiting: get_or_create_node
    creating edge EN: 45 -> EN: 46
   exiting: process_node
   next to process: EN: 46
   entering: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
   exiting: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
   peek worklist: EN: 2
   entering: process_node: EN: 46
    point: callstring: [] before SN: 4 (from SN: 3 (bb: 2)) , state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {_8, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {_8, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {_8, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
      0x3ab4ea0: constant_svalue('int', 0)
     dest_state maybe reachable svalues:
      0x3ab4ea0: constant_svalue('int', 0)
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: get_or_create_node
     point: callstring: [] before (SN: 4 stmt: 0):  <L0>:
     state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {_8, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {_8, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {_8, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}created EN: 47
     point: callstring: [] before (SN: 4 stmt: 0):  <L0>:
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {_8, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    exiting: get_or_create_node
    creating edge EN: 46 -> EN: 47
   exiting: process_node
   next to process: EN: 47
   peek worklist: EN: 2
   entering: process_node: EN: 47
    point: callstring: [] before (SN: 4 stmt: 0):  <L0>:, state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {_8, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    entering: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
     <L0>:
    exiting: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {_8, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {_8, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
      0x3ab4ea0: constant_svalue('int', 0)
     dest_state maybe reachable svalues:
      0x3ab4ea0: constant_svalue('int', 0)
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    entering: get_or_create_node
     point: callstring: [] before (SN: 4 stmt: 1):  return _8;
     state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {_8, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {_8, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {_8, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}created EN: 48
     point: callstring: [] before (SN: 4 stmt: 1):  return _8;
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {_8, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    exiting: get_or_create_node
    creating edge EN: 47 -> EN: 48
   exiting: process_node
   next to process: EN: 48
   peek worklist: EN: 2
   entering: process_node: EN: 48
    point: callstring: [] before (SN: 4 stmt: 1):  return _8;, state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {_8, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    entering: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
     return _8;
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     exiting: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
    exiting: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {_8, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {_8, value: (int)0}, region: {<anonymous>, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
      0x3ab4ea0: constant_svalue('int', 0)
     dest_state maybe reachable svalues:
      0x3ab4ea0: constant_svalue('int', 0)
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    entering: get_or_create_node
     point: callstring: [] after SN: 4
     state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {_8, value: (int)0}, region: {<anonymous>, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {_8, value: (int)0}, region: {<anonymous>, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {_8, value: (int)0}, region: {<anonymous>, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}created EN: 49
     point: callstring: [] after SN: 4
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {_8, value: (int)0}, region: {<anonymous>, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    exiting: get_or_create_node
    creating edge EN: 48 -> EN: 49
   exiting: process_node
   next to process: EN: 49
   peek worklist: EN: 2
   entering: process_node: EN: 49
    point: callstring: [] after SN: 4, state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {_8, value: (int)0}, region: {<anonymous>, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    considering SN: 4 -> SN: 5 ()
    entering: on_edge
     entering: on_edge
     exiting: on_edge
     entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
      src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {_8, value: (int)0}, region: {<anonymous>, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
      dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {_8, value: (int)0}, region: {<anonymous>, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
      uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
      src_state known reachable svalues:
       0x3ab4ea0: constant_svalue('int', 0)
      dest_state maybe reachable svalues:
       0x3ab4ea0: constant_svalue('int', 0)
     exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    exiting: on_edge
    entering: get_or_create_node
     point: callstring: [] before SN: 5 (from SN: 4 (bb: 3)) 
     state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {_8, value: (int)0}, region: {<anonymous>, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
      num_ssas_purged: 1
      num_decl_purged: 0
      entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
       src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {_8, value: (int)0}, region: {<anonymous>, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
       dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {<anonymous>, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
       uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
       src_state known reachable svalues:
        0x3ab4ea0: constant_svalue('int', 0)
       dest_state maybe reachable svalues:
        0x3ab4ea0: constant_svalue('int', 0)
      exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {<anonymous>, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {<anonymous>, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}created EN: 50
     point: callstring: [] before SN: 5 (from SN: 4 (bb: 3)) 
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {<anonymous>, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    exiting: get_or_create_node
    creating edge EN: 49 -> EN: 50
   exiting: process_node
   next to process: EN: 50
   entering: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
   exiting: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
   peek worklist: EN: 2
   entering: process_node: EN: 50
    point: callstring: [] before SN: 5 (from SN: 4 (bb: 3)) , state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {<anonymous>, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {<anonymous>, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {<anonymous>, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
      0x3ab4ea0: constant_svalue('int', 0)
     dest_state maybe reachable svalues:
      0x3ab4ea0: constant_svalue('int', 0)
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: get_or_create_node
     point: callstring: [] after SN: 5
     state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {<anonymous>, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {<anonymous>, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {<anonymous>, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}created EN: 51
     point: callstring: [] after SN: 5
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {<anonymous>, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    exiting: get_or_create_node
    creating edge EN: 50 -> EN: 51
   exiting: process_node
   next to process: EN: 51
   peek worklist: EN: 2
   entering: process_node: EN: 51
    point: callstring: [] after SN: 5, state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {<anonymous>, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    entering: detect_leaks: EN: 51
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
      src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'main'@1}, {clusters within frame: 'main'@1 {region: {<anonymous>, value: (int)0}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
      dest_state: {rmodel: {stack depth: 0 {}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
      extra_sval: (int)0
      uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
      src_state known reachable svalues:
       0x3ab4ea0: constant_svalue('int', 0)
      dest_state maybe reachable svalues:
       0x3ab4ea0: constant_svalue('int', 0)
     exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    exiting: detect_leaks
   exiting: process_node
   next to process: EN: 2
   entering: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
   exiting: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
   peek worklist: EN: 3
   entering: process_node: EN: 2
    point: callstring: [] before SN: 6 (NULL from-edge) , state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    entering: get_or_create_node
     point: callstring: [] after SN: 6
     state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}created EN: 52
     point: callstring: [] after SN: 6
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    exiting: get_or_create_node
    creating edge EN: 2 -> EN: 52
   exiting: process_node
   next to process: EN: 52
   peek worklist: EN: 3
   entering: process_node: EN: 52
    point: callstring: [] after SN: 6, state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    considering SN: 6 -> SN: 7 ( (flags FALLTHRU))
    entering: on_edge
     entering: on_edge
     exiting: on_edge
     entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
      src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
      dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
      uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
      src_state known reachable svalues:
      dest_state maybe reachable svalues:
     exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    exiting: on_edge
    entering: get_or_create_node
     point: callstring: [] before SN: 7 (from SN: 6 (bb: 0)) 
     state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}created EN: 53
     point: callstring: [] before SN: 7 (from SN: 6 (bb: 0)) 
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    exiting: get_or_create_node
    creating edge EN: 52 -> EN: 53
   exiting: process_node
   next to process: EN: 53
   entering: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
   exiting: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
   peek worklist: EN: 3
   entering: process_node: EN: 53
    point: callstring: [] before SN: 7 (from SN: 6 (bb: 0)) , state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
     dest_state maybe reachable svalues:
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: get_or_create_node
     point: callstring: [] before (SN: 7 stmt: 0):  _1 = t_13(D)->counting;
     state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}created EN: 54
     point: callstring: [] before (SN: 7 stmt: 0):  _1 = t_13(D)->counting;
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    exiting: get_or_create_node
    creating edge EN: 53 -> EN: 54
   exiting: process_node
   next to process: EN: 54
   peek worklist: EN: 3
   entering: process_node: EN: 54
    point: callstring: [] before (SN: 7 stmt: 0):  _1 = t_13(D)->counting;, state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    entering: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
     _1 = t_13(D)->counting;
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     exiting: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: get_state
     exiting: get_state
    exiting: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_1, value: INIT_VAL((*INIT_VAL(t_13(D))).counting)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {INIT_VAL(t_13(D))}, ec1: {(void *)0B == [m_constant]'0B'}}constraints:{0: ec0: {INIT_VAL(t_13(D))} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
     dest_state maybe reachable svalues:
      0x3ad52e0: initial_svalue('_Bool', field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), '_Bool', 'counting'))
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    entering: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
     _2 = (int) _1;
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     exiting: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
    exiting: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_1, value: INIT_VAL((*INIT_VAL(t_13(D))).counting)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_1, value: INIT_VAL((*INIT_VAL(t_13(D))).counting)}, region: {_2, value: INIT_VAL((*INIT_VAL(t_13(D))).counting)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
      0x3ad52e0: initial_svalue('_Bool', field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), '_Bool', 'counting'))
     dest_state maybe reachable svalues:
      0x3ad52e0: initial_svalue('_Bool', field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), '_Bool', 'counting'))
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     num_ssas_purged: 1
     num_decl_purged: 0
     entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
      src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_1, value: INIT_VAL((*INIT_VAL(t_13(D))).counting)}, region: {_2, value: INIT_VAL((*INIT_VAL(t_13(D))).counting)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
      dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_2, value: INIT_VAL((*INIT_VAL(t_13(D))).counting)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
      uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
      src_state known reachable svalues:
       0x3ad52e0: initial_svalue('_Bool', field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), '_Bool', 'counting'))
      dest_state maybe reachable svalues:
       0x3ad52e0: initial_svalue('_Bool', field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), '_Bool', 'counting'))
     exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    entering: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
     __analyzer_describe (0, _2);
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
    exiting: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_2, value: INIT_VAL((*INIT_VAL(t_13(D))).counting)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_2, value: INIT_VAL((*INIT_VAL(t_13(D))).counting)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
      0x3ad52e0: initial_svalue('_Bool', field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), '_Bool', 'counting'))
     dest_state maybe reachable svalues:
      0x3ad52e0: initial_svalue('_Bool', field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), '_Bool', 'counting'))
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     num_ssas_purged: 1
     num_decl_purged: 0
     entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
      src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_2, value: INIT_VAL((*INIT_VAL(t_13(D))).counting)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
      dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
      uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
      src_state known reachable svalues:
       0x3ad52e0: initial_svalue('_Bool', field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), '_Bool', 'counting'))
      dest_state maybe reachable svalues:
     exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    entering: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
     _3 = t_13(D)->counting;
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     exiting: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: get_state
     exiting: get_state
    exiting: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_3, value: INIT_VAL((*INIT_VAL(t_13(D))).counting)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
     dest_state maybe reachable svalues:
      0x3ad52e0: initial_svalue('_Bool', field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), '_Bool', 'counting'))
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    entering: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
     _4 = ~_3;
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     exiting: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
    exiting: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_3, value: INIT_VAL((*INIT_VAL(t_13(D))).counting)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_3, value: INIT_VAL((*INIT_VAL(t_13(D))).counting)}, region: {_4, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
      0x3ad52e0: initial_svalue('_Bool', field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), '_Bool', 'counting'))
     dest_state maybe reachable svalues:
      0x3ad52e0: initial_svalue('_Bool', field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), '_Bool', 'counting'))
      0x3ad4ff0: unaryop_svalue (bit_not_expr, initial_svalue('_Bool', field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), '_Bool', 'counting')))
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     num_ssas_purged: 1
     num_decl_purged: 0
     entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
      src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_3, value: INIT_VAL((*INIT_VAL(t_13(D))).counting)}, region: {_4, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
      dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_4, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
      uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
      src_state known reachable svalues:
       0x3ad52e0: initial_svalue('_Bool', field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), '_Bool', 'counting'))
       0x3ad4ff0: unaryop_svalue (bit_not_expr, initial_svalue('_Bool', field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), '_Bool', 'counting')))
      dest_state maybe reachable svalues:
       0x3ad4ff0: unaryop_svalue (bit_not_expr, initial_svalue('_Bool', field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), '_Bool', 'counting')))
     exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    entering: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
     _5 = (int) _4;
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     exiting: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
    exiting: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_4, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_4, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}, region: {_5, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
      0x3ad4ff0: unaryop_svalue (bit_not_expr, initial_svalue('_Bool', field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), '_Bool', 'counting')))
     dest_state maybe reachable svalues:
      0x3ad4ff0: unaryop_svalue (bit_not_expr, initial_svalue('_Bool', field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), '_Bool', 'counting')))
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     num_ssas_purged: 1
     num_decl_purged: 0
     entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
      src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_4, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}, region: {_5, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
      dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_5, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
      uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
      src_state known reachable svalues:
       0x3ad4ff0: unaryop_svalue (bit_not_expr, initial_svalue('_Bool', field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), '_Bool', 'counting')))
      dest_state maybe reachable svalues:
       0x3ad4ff0: unaryop_svalue (bit_not_expr, initial_svalue('_Bool', field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), '_Bool', 'counting')))
     exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    entering: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
     __analyzer_eval (_5);
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
    exiting: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_5, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_5, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
      0x3ad4ff0: unaryop_svalue (bit_not_expr, initial_svalue('_Bool', field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), '_Bool', 'counting')))
     dest_state maybe reachable svalues:
      0x3ad4ff0: unaryop_svalue (bit_not_expr, initial_svalue('_Bool', field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), '_Bool', 'counting')))
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    entering: get_or_create_node
     point: callstring: [] after SN: 7
     state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_5, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_5, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_5, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}created EN: 55
     point: callstring: [] after SN: 7
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_5, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
    exiting: get_or_create_node
    creating edge EN: 54 -> EN: 55
   exiting: process_node
   next to process: EN: 55
   peek worklist: EN: 3
   entering: process_node: EN: 55
    point: callstring: [] after SN: 7, state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_5, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
    considering SN: 7 -> SN: 16 (call)
    entering: on_edge
     entering: on_edge
     exiting: on_edge
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     exiting: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
      src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_5, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
      dest_state: {rmodel: {stack depth: 2 {frame (index 1): frame: '__analyzer_eval'@2, frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_5, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}clusters within frame: '__analyzer_eval'@2 {, region: {a, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
      uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
      src_state known reachable svalues:
       0x3ad4ff0: unaryop_svalue (bit_not_expr, initial_svalue('_Bool', field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), '_Bool', 'counting')))
      dest_state maybe reachable svalues:
       0x3ad4ff0: unaryop_svalue (bit_not_expr, initial_svalue('_Bool', field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), '_Bool', 'counting')))
     exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    exiting: on_edge
    entering: get_or_create_node
     point: callstring: [(SN: 18 -> SN: 8 in ss_out)] before SN: 16 (NULL from-edge) 
     state: {rmodel: {stack depth: 2 {frame (index 1): frame: '__analyzer_eval'@2, frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_5, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}clusters within frame: '__analyzer_eval'@2 {, region: {a, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: '__analyzer_eval'@2, frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_5, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}clusters within frame: '__analyzer_eval'@2 {, region: {a, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     stack depth: 2 {frame (index 1): frame: '__analyzer_eval'@2, frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_5, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}clusters within frame: '__analyzer_eval'@2 {, region: {a, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}created EN: 56
     point: callstring: [(SN: 18 -> SN: 8 in ss_out)] before SN: 16 (NULL from-edge) 
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: '__analyzer_eval'@2, frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_5, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}clusters within frame: '__analyzer_eval'@2 {, region: {a, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
    exiting: get_or_create_node
    creating edge EN: 55 -> EN: 56
    considering SN: 7 -> SN: 8 (intraproc link)
    entering: on_edge
     entering: on_edge
      rejecting interprocedural edge
     exiting: on_edge
    exiting: on_edge
    skipping impossible edge to SN: 8
   exiting: process_node
   next to process: EN: 56
   entering: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
   exiting: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
   peek worklist: EN: 3
   entering: process_node: EN: 56
    point: callstring: [(SN: 18 -> SN: 8 in ss_out)] before SN: 16 (NULL from-edge) , state: {rmodel: {stack depth: 2 {frame (index 1): frame: '__analyzer_eval'@2, frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_5, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}clusters within frame: '__analyzer_eval'@2 {, region: {a, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
    entering: get_or_create_node
     point: callstring: [(SN: 18 -> SN: 8 in ss_out)] after SN: 16
     state: {rmodel: {stack depth: 2 {frame (index 1): frame: '__analyzer_eval'@2, frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_5, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}clusters within frame: '__analyzer_eval'@2 {, region: {a, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: '__analyzer_eval'@2, frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_5, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}clusters within frame: '__analyzer_eval'@2 {, region: {a, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     stack depth: 2 {frame (index 1): frame: '__analyzer_eval'@2, frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_5, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}clusters within frame: '__analyzer_eval'@2 {, region: {a, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}created EN: 57
     point: callstring: [(SN: 18 -> SN: 8 in ss_out)] after SN: 16
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: '__analyzer_eval'@2, frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_5, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}clusters within frame: '__analyzer_eval'@2 {, region: {a, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
    exiting: get_or_create_node
    creating edge EN: 56 -> EN: 57
   exiting: process_node
   next to process: EN: 57
   peek worklist: EN: 3
   entering: process_node: EN: 57
    point: callstring: [(SN: 18 -> SN: 8 in ss_out)] after SN: 16, state: {rmodel: {stack depth: 2 {frame (index 1): frame: '__analyzer_eval'@2, frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_5, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}clusters within frame: '__analyzer_eval'@2 {, region: {a, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
    considering SN: 16 -> SN: 17 ( (flags FALLTHRU))
    entering: on_edge
     entering: on_edge
     exiting: on_edge
     entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
      src_state: {rmodel: {stack depth: 2 {frame (index 1): frame: '__analyzer_eval'@2, frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_5, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}clusters within frame: '__analyzer_eval'@2 {, region: {a, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
      dest_state: {rmodel: {stack depth: 2 {frame (index 1): frame: '__analyzer_eval'@2, frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_5, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}clusters within frame: '__analyzer_eval'@2 {, region: {a, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
      uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
      src_state known reachable svalues:
       0x3ad4ff0: unaryop_svalue (bit_not_expr, initial_svalue('_Bool', field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), '_Bool', 'counting')))
      dest_state maybe reachable svalues:
       0x3ad4ff0: unaryop_svalue (bit_not_expr, initial_svalue('_Bool', field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), '_Bool', 'counting')))
     exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    exiting: on_edge
    entering: get_or_create_node
     point: callstring: [(SN: 18 -> SN: 8 in ss_out)] before SN: 17 (from SN: 16 (bb: 0)) 
     state: {rmodel: {stack depth: 2 {frame (index 1): frame: '__analyzer_eval'@2, frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_5, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}clusters within frame: '__analyzer_eval'@2 {, region: {a, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: '__analyzer_eval'@2, frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_5, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}clusters within frame: '__analyzer_eval'@2 {, region: {a, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     stack depth: 2 {frame (index 1): frame: '__analyzer_eval'@2, frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_5, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}clusters within frame: '__analyzer_eval'@2 {, region: {a, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}created EN: 58
     point: callstring: [(SN: 18 -> SN: 8 in ss_out)] before SN: 17 (from SN: 16 (bb: 0)) 
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: '__analyzer_eval'@2, frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_5, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}clusters within frame: '__analyzer_eval'@2 {, region: {a, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
    exiting: get_or_create_node
    creating edge EN: 57 -> EN: 58
   exiting: process_node
   next to process: EN: 58
   entering: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
   exiting: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
   peek worklist: EN: 3
   entering: process_node: EN: 58
    point: callstring: [(SN: 18 -> SN: 8 in ss_out)] before SN: 17 (from SN: 16 (bb: 0)) , state: {rmodel: {stack depth: 2 {frame (index 1): frame: '__analyzer_eval'@2, frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_5, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}clusters within frame: '__analyzer_eval'@2 {, region: {a, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 2 {frame (index 1): frame: '__analyzer_eval'@2, frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_5, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}clusters within frame: '__analyzer_eval'@2 {, region: {a, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     dest_state: {rmodel: {stack depth: 2 {frame (index 1): frame: '__analyzer_eval'@2, frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_5, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}clusters within frame: '__analyzer_eval'@2 {, region: {a, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
      0x3ad4ff0: unaryop_svalue (bit_not_expr, initial_svalue('_Bool', field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), '_Bool', 'counting')))
     dest_state maybe reachable svalues:
      0x3ad4ff0: unaryop_svalue (bit_not_expr, initial_svalue('_Bool', field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), '_Bool', 'counting')))
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: get_or_create_node
     point: callstring: [(SN: 18 -> SN: 8 in ss_out)] before (SN: 17 stmt: 0):  return;
     state: {rmodel: {stack depth: 2 {frame (index 1): frame: '__analyzer_eval'@2, frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_5, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}clusters within frame: '__analyzer_eval'@2 {, region: {a, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: '__analyzer_eval'@2, frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_5, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}clusters within frame: '__analyzer_eval'@2 {, region: {a, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     stack depth: 2 {frame (index 1): frame: '__analyzer_eval'@2, frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_5, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}clusters within frame: '__analyzer_eval'@2 {, region: {a, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}created EN: 59
     point: callstring: [(SN: 18 -> SN: 8 in ss_out)] before (SN: 17 stmt: 0):  return;
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: '__analyzer_eval'@2, frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_5, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}clusters within frame: '__analyzer_eval'@2 {, region: {a, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
    exiting: get_or_create_node
    creating edge EN: 58 -> EN: 59
   exiting: process_node
   next to process: EN: 59
   peek worklist: EN: 3
   entering: process_node: EN: 59
    point: callstring: [(SN: 18 -> SN: 8 in ss_out)] before (SN: 17 stmt: 0):  return;, state: {rmodel: {stack depth: 2 {frame (index 1): frame: '__analyzer_eval'@2, frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_5, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}clusters within frame: '__analyzer_eval'@2 {, region: {a, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
    entering: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
     return;
    exiting: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 2 {frame (index 1): frame: '__analyzer_eval'@2, frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_5, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}clusters within frame: '__analyzer_eval'@2 {, region: {a, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     dest_state: {rmodel: {stack depth: 2 {frame (index 1): frame: '__analyzer_eval'@2, frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_5, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}clusters within frame: '__analyzer_eval'@2 {, region: {a, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
      0x3ad4ff0: unaryop_svalue (bit_not_expr, initial_svalue('_Bool', field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), '_Bool', 'counting')))
     dest_state maybe reachable svalues:
      0x3ad4ff0: unaryop_svalue (bit_not_expr, initial_svalue('_Bool', field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), '_Bool', 'counting')))
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    entering: get_or_create_node
     point: callstring: [(SN: 18 -> SN: 8 in ss_out)] after SN: 17
     state: {rmodel: {stack depth: 2 {frame (index 1): frame: '__analyzer_eval'@2, frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_5, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}clusters within frame: '__analyzer_eval'@2 {, region: {a, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: '__analyzer_eval'@2, frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_5, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}clusters within frame: '__analyzer_eval'@2 {, region: {a, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     stack depth: 2 {frame (index 1): frame: '__analyzer_eval'@2, frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_5, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}clusters within frame: '__analyzer_eval'@2 {, region: {a, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}created EN: 60
     point: callstring: [(SN: 18 -> SN: 8 in ss_out)] after SN: 17
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: '__analyzer_eval'@2, frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_5, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}clusters within frame: '__analyzer_eval'@2 {, region: {a, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
    exiting: get_or_create_node
    creating edge EN: 59 -> EN: 60
   exiting: process_node
   next to process: EN: 60
   peek worklist: EN: 3
   entering: process_node: EN: 60
    point: callstring: [(SN: 18 -> SN: 8 in ss_out)] after SN: 17, state: {rmodel: {stack depth: 2 {frame (index 1): frame: '__analyzer_eval'@2, frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_5, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}clusters within frame: '__analyzer_eval'@2 {, region: {a, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
    considering SN: 17 -> SN: 18 ()
    entering: on_edge
     entering: on_edge
     exiting: on_edge
     entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
      src_state: {rmodel: {stack depth: 2 {frame (index 1): frame: '__analyzer_eval'@2, frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_5, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}clusters within frame: '__analyzer_eval'@2 {, region: {a, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
      dest_state: {rmodel: {stack depth: 2 {frame (index 1): frame: '__analyzer_eval'@2, frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_5, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}clusters within frame: '__analyzer_eval'@2 {, region: {a, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
      uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
      src_state known reachable svalues:
       0x3ad4ff0: unaryop_svalue (bit_not_expr, initial_svalue('_Bool', field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), '_Bool', 'counting')))
      dest_state maybe reachable svalues:
       0x3ad4ff0: unaryop_svalue (bit_not_expr, initial_svalue('_Bool', field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), '_Bool', 'counting')))
     exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    exiting: on_edge
    entering: get_or_create_node
     point: callstring: [(SN: 18 -> SN: 8 in ss_out)] before SN: 18 (from SN: 17 (bb: 2)) 
     state: {rmodel: {stack depth: 2 {frame (index 1): frame: '__analyzer_eval'@2, frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_5, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}clusters within frame: '__analyzer_eval'@2 {, region: {a, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: '__analyzer_eval'@2, frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_5, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}clusters within frame: '__analyzer_eval'@2 {, region: {a, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     stack depth: 2 {frame (index 1): frame: '__analyzer_eval'@2, frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_5, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}clusters within frame: '__analyzer_eval'@2 {, region: {a, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}created EN: 61
     point: callstring: [(SN: 18 -> SN: 8 in ss_out)] before SN: 18 (from SN: 17 (bb: 2)) 
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: '__analyzer_eval'@2, frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_5, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}clusters within frame: '__analyzer_eval'@2 {, region: {a, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
    exiting: get_or_create_node
    creating edge EN: 60 -> EN: 61
   exiting: process_node
   next to process: EN: 61
   entering: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
   exiting: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
   peek worklist: EN: 3
   entering: process_node: EN: 61
    point: callstring: [(SN: 18 -> SN: 8 in ss_out)] before SN: 18 (from SN: 17 (bb: 2)) , state: {rmodel: {stack depth: 2 {frame (index 1): frame: '__analyzer_eval'@2, frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_5, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}clusters within frame: '__analyzer_eval'@2 {, region: {a, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 2 {frame (index 1): frame: '__analyzer_eval'@2, frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_5, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}clusters within frame: '__analyzer_eval'@2 {, region: {a, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     dest_state: {rmodel: {stack depth: 2 {frame (index 1): frame: '__analyzer_eval'@2, frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_5, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}clusters within frame: '__analyzer_eval'@2 {, region: {a, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
      0x3ad4ff0: unaryop_svalue (bit_not_expr, initial_svalue('_Bool', field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), '_Bool', 'counting')))
     dest_state maybe reachable svalues:
      0x3ad4ff0: unaryop_svalue (bit_not_expr, initial_svalue('_Bool', field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), '_Bool', 'counting')))
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: get_or_create_node
     point: callstring: [(SN: 18 -> SN: 8 in ss_out)] after SN: 18
     state: {rmodel: {stack depth: 2 {frame (index 1): frame: '__analyzer_eval'@2, frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_5, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}clusters within frame: '__analyzer_eval'@2 {, region: {a, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: '__analyzer_eval'@2, frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_5, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}clusters within frame: '__analyzer_eval'@2 {, region: {a, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     stack depth: 2 {frame (index 1): frame: '__analyzer_eval'@2, frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_5, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}clusters within frame: '__analyzer_eval'@2 {, region: {a, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}created EN: 62
     point: callstring: [(SN: 18 -> SN: 8 in ss_out)] after SN: 18
     pruned_state: {rmodel: {stack depth: 2 {frame (index 1): frame: '__analyzer_eval'@2, frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_5, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}clusters within frame: '__analyzer_eval'@2 {, region: {a, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
    exiting: get_or_create_node
    creating edge EN: 61 -> EN: 62
   exiting: process_node
   next to process: EN: 62
   peek worklist: EN: 3
   entering: process_node: EN: 62
    point: callstring: [(SN: 18 -> SN: 8 in ss_out)] after SN: 18, state: {rmodel: {stack depth: 2 {frame (index 1): frame: '__analyzer_eval'@2, frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_5, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}clusters within frame: '__analyzer_eval'@2 {, region: {a, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
    entering: detect_leaks: EN: 62
    exiting: detect_leaks
    considering SN: 18 -> SN: 8 (return)
    entering: on_edge
     entering: on_edge
     exiting: on_edge
     entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
      src_state: {rmodel: {stack depth: 2 {frame (index 1): frame: '__analyzer_eval'@2, frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_5, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}clusters within frame: '__analyzer_eval'@2 {, region: {a, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
      dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_5, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
      uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
      src_state known reachable svalues:
       0x3ad4ff0: unaryop_svalue (bit_not_expr, initial_svalue('_Bool', field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), '_Bool', 'counting')))
      dest_state maybe reachable svalues:
       0x3ad4ff0: unaryop_svalue (bit_not_expr, initial_svalue('_Bool', field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), '_Bool', 'counting')))
     exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    exiting: on_edge
    entering: get_or_create_node
     point: callstring: [] before SN: 8 (NULL from-edge) 
     state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_5, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
      num_ssas_purged: 1
      num_decl_purged: 0
      entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
       src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_5, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
       dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
       uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
       src_state known reachable svalues:
        0x3ad4ff0: unaryop_svalue (bit_not_expr, initial_svalue('_Bool', field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), '_Bool', 'counting')))
       dest_state maybe reachable svalues:
      exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}created EN: 63
     point: callstring: [] before SN: 8 (NULL from-edge) 
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
    exiting: get_or_create_node
    creating edge EN: 62 -> EN: 63
   exiting: process_node
   next to process: EN: 63
   entering: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
   exiting: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
   peek worklist: EN: 3
   entering: process_node: EN: 63
    point: callstring: [] before SN: 8 (NULL from-edge) , state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
    entering: get_or_create_node
     point: callstring: [] before (SN: 8 stmt: 0):  _6 = t_13(D)->counting;
     state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}created EN: 64
     point: callstring: [] before (SN: 8 stmt: 0):  _6 = t_13(D)->counting;
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
    exiting: get_or_create_node
    creating edge EN: 63 -> EN: 64
   exiting: process_node
   next to process: EN: 64
   peek worklist: EN: 3
   entering: process_node: EN: 64
    point: callstring: [] before (SN: 8 stmt: 0):  _6 = t_13(D)->counting;, state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
    entering: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
     _6 = t_13(D)->counting;
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     exiting: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: get_state
     exiting: get_state
    exiting: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_6, value: INIT_VAL((*INIT_VAL(t_13(D))).counting)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
     dest_state maybe reachable svalues:
      0x3ad52e0: initial_svalue('_Bool', field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), '_Bool', 'counting'))
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    entering: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
     _7 = ~_6;
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     exiting: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
    exiting: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_6, value: INIT_VAL((*INIT_VAL(t_13(D))).counting)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_6, value: INIT_VAL((*INIT_VAL(t_13(D))).counting)}, region: {_7, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
      0x3ad52e0: initial_svalue('_Bool', field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), '_Bool', 'counting'))
     dest_state maybe reachable svalues:
      0x3ad52e0: initial_svalue('_Bool', field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), '_Bool', 'counting'))
      0x3ad4ff0: unaryop_svalue (bit_not_expr, initial_svalue('_Bool', field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), '_Bool', 'counting')))
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     num_ssas_purged: 1
     num_decl_purged: 0
     entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
      src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_6, value: INIT_VAL((*INIT_VAL(t_13(D))).counting)}, region: {_7, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
      dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_7, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
      uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
      src_state known reachable svalues:
       0x3ad52e0: initial_svalue('_Bool', field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), '_Bool', 'counting'))
       0x3ad4ff0: unaryop_svalue (bit_not_expr, initial_svalue('_Bool', field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), '_Bool', 'counting')))
      dest_state maybe reachable svalues:
       0x3ad4ff0: unaryop_svalue (bit_not_expr, initial_svalue('_Bool', field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), '_Bool', 'counting')))
     exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    entering: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
     if (_7 != 0)
    exiting: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_7, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_7, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
      0x3ad4ff0: unaryop_svalue (bit_not_expr, initial_svalue('_Bool', field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), '_Bool', 'counting')))
     dest_state maybe reachable svalues:
      0x3ad4ff0: unaryop_svalue (bit_not_expr, initial_svalue('_Bool', field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), '_Bool', 'counting')))
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    entering: get_or_create_node
     point: callstring: [] after SN: 8
     state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_7, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_7, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_7, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}created EN: 65
     point: callstring: [] after SN: 8
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_7, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
    exiting: get_or_create_node
    creating edge EN: 64 -> EN: 65
   exiting: process_node
   next to process: EN: 65
   peek worklist: EN: 3
   entering: process_node: EN: 65
    point: callstring: [] after SN: 8, state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_7, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
    considering SN: 8 -> SN: 9 (true (flags TRUE_VALUE))
    entering: on_edge
     entering: on_edge
     exiting: on_edge
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
      src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_7, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
      dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_7, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}, ec2: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}, ec3: {(_Bool)0 == [m_constant]'0'}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}1: ec2: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))} != ec3: {(_Bool)0 == [m_constant]'0'}}}}}
      uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
      src_state known reachable svalues:
       0x3ad4ff0: unaryop_svalue (bit_not_expr, initial_svalue('_Bool', field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), '_Bool', 'counting')))
      dest_state maybe reachable svalues:
       0x3ad4ff0: unaryop_svalue (bit_not_expr, initial_svalue('_Bool', field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), '_Bool', 'counting')))
     exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    exiting: on_edge
    entering: get_or_create_node
     point: callstring: [] before SN: 9 (from SN: 8 (bb: 2)) 
     state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_7, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}, ec2: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}, ec3: {(_Bool)0 == [m_constant]'0'}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}1: ec2: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))} != ec3: {(_Bool)0 == [m_constant]'0'}}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
      num_ssas_purged: 1
      num_decl_purged: 0
      entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
       src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_7, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}, ec2: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}, ec3: {(_Bool)0 == [m_constant]'0'}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}1: ec2: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))} != ec3: {(_Bool)0 == [m_constant]'0'}}}}}
       dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}, ec2: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}, ec3: {(_Bool)0 == [m_constant]'0'}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}1: ec2: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))} != ec3: {(_Bool)0 == [m_constant]'0'}}}}}
       uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
       src_state known reachable svalues:
        0x3ad4ff0: unaryop_svalue (bit_not_expr, initial_svalue('_Bool', field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), '_Bool', 'counting')))
       dest_state maybe reachable svalues:
      exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(_Bool)0 == [m_constant]'0'}, ec1: {(void *)0B == [m_constant]'0B'}, ec2: {INIT_VAL(t_13(D))}, ec3: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}constraints:{0: ec2: {INIT_VAL(t_13(D))} != ec1: {(void *)0B == [m_constant]'0B'}1: ec3: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))} != ec0: {(_Bool)0 == [m_constant]'0'}}}}}
     stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(_Bool)0 == [m_constant]'0'}, ec1: {(void *)0B == [m_constant]'0B'}, ec2: {INIT_VAL(t_13(D))}, ec3: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}constraints:{0: ec2: {INIT_VAL(t_13(D))} != ec1: {(void *)0B == [m_constant]'0B'}1: ec3: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))} != ec0: {(_Bool)0 == [m_constant]'0'}}}created EN: 66
     point: callstring: [] before SN: 9 (from SN: 8 (bb: 2)) 
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(_Bool)0 == [m_constant]'0'}, ec1: {(void *)0B == [m_constant]'0B'}, ec2: {INIT_VAL(t_13(D))}, ec3: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}constraints:{0: ec2: {INIT_VAL(t_13(D))} != ec1: {(void *)0B == [m_constant]'0B'}1: ec3: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))} != ec0: {(_Bool)0 == [m_constant]'0'}}}}}
    exiting: get_or_create_node
    creating edge EN: 65 -> EN: 66
    considering SN: 8 -> SN: 10 (false (flags FALSE_VALUE))
    entering: on_edge
     entering: on_edge
     exiting: on_edge
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
      src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_7, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
      dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_7, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}, ec2: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting)) == (_Bool)0 == [m_constant]'0'}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
      uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
      src_state known reachable svalues:
       0x3ad4ff0: unaryop_svalue (bit_not_expr, initial_svalue('_Bool', field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), '_Bool', 'counting')))
      dest_state maybe reachable svalues:
       0x3ad4ff0: unaryop_svalue (bit_not_expr, initial_svalue('_Bool', field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), '_Bool', 'counting')))
     exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    exiting: on_edge
    entering: get_or_create_node
     point: callstring: [] before SN: 10 (from SN: 8 (bb: 2)) .MEM_11 = PHI <.MEM_15(2), .MEM_18(3)>
     state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_7, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}, ec2: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting)) == (_Bool)0 == [m_constant]'0'}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
      num_ssas_purged: 1
      num_decl_purged: 0
      entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
       src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_7, value: (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}, ec2: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting)) == (_Bool)0 == [m_constant]'0'}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
       dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}, ec2: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting)) == (_Bool)0 == [m_constant]'0'}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
       uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
       src_state known reachable svalues:
        0x3ad4ff0: unaryop_svalue (bit_not_expr, initial_svalue('_Bool', field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), '_Bool', 'counting')))
       dest_state maybe reachable svalues:
      exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(_Bool)0 == (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting)) == [m_constant]'0'}, ec1: {(void *)0B == [m_constant]'0B'}, ec2: {INIT_VAL(t_13(D))}}constraints:{0: ec2: {INIT_VAL(t_13(D))} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
     stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(_Bool)0 == (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting)) == [m_constant]'0'}, ec1: {(void *)0B == [m_constant]'0B'}, ec2: {INIT_VAL(t_13(D))}}constraints:{0: ec2: {INIT_VAL(t_13(D))} != ec1: {(void *)0B == [m_constant]'0B'}}}created EN: 67
     point: callstring: [] before SN: 10 (from SN: 8 (bb: 2)) .MEM_11 = PHI <.MEM_15(2), .MEM_18(3)>
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(_Bool)0 == (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting)) == [m_constant]'0'}, ec1: {(void *)0B == [m_constant]'0B'}, ec2: {INIT_VAL(t_13(D))}}constraints:{0: ec2: {INIT_VAL(t_13(D))} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
    exiting: get_or_create_node
    creating edge EN: 65 -> EN: 67
   exiting: process_node
   next to process: EN: 66
   entering: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
   exiting: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
   peek worklist: EN: 67
   entering: process_node: EN: 66
    point: callstring: [] before SN: 9 (from SN: 8 (bb: 2)) , state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(_Bool)0 == [m_constant]'0'}, ec1: {(void *)0B == [m_constant]'0B'}, ec2: {INIT_VAL(t_13(D))}, ec3: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}constraints:{0: ec2: {INIT_VAL(t_13(D))} != ec1: {(void *)0B == [m_constant]'0B'}1: ec3: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))} != ec0: {(_Bool)0 == [m_constant]'0'}}}}}
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(_Bool)0 == [m_constant]'0'}, ec1: {(void *)0B == [m_constant]'0B'}, ec2: {INIT_VAL(t_13(D))}, ec3: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}constraints:{0: ec2: {INIT_VAL(t_13(D))} != ec1: {(void *)0B == [m_constant]'0B'}1: ec3: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))} != ec0: {(_Bool)0 == [m_constant]'0'}}}}}
     dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(_Bool)0 == [m_constant]'0'}, ec1: {(void *)0B == [m_constant]'0B'}, ec2: {INIT_VAL(t_13(D))}, ec3: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}constraints:{0: ec2: {INIT_VAL(t_13(D))} != ec1: {(void *)0B == [m_constant]'0B'}1: ec3: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))} != ec0: {(_Bool)0 == [m_constant]'0'}}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
     dest_state maybe reachable svalues:
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: get_or_create_node
     point: callstring: [] before (SN: 9 stmt: 0):  _8 = t_13(D)->uu.newstr;
     state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(_Bool)0 == [m_constant]'0'}, ec1: {(void *)0B == [m_constant]'0B'}, ec2: {INIT_VAL(t_13(D))}, ec3: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}constraints:{0: ec2: {INIT_VAL(t_13(D))} != ec1: {(void *)0B == [m_constant]'0B'}1: ec3: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))} != ec0: {(_Bool)0 == [m_constant]'0'}}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(_Bool)0 == [m_constant]'0'}, ec1: {(void *)0B == [m_constant]'0B'}, ec2: {INIT_VAL(t_13(D))}, ec3: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}constraints:{0: ec2: {INIT_VAL(t_13(D))} != ec1: {(void *)0B == [m_constant]'0B'}1: ec3: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))} != ec0: {(_Bool)0 == [m_constant]'0'}}}}}
     stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(_Bool)0 == [m_constant]'0'}, ec1: {(void *)0B == [m_constant]'0B'}, ec2: {INIT_VAL(t_13(D))}, ec3: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}constraints:{0: ec2: {INIT_VAL(t_13(D))} != ec1: {(void *)0B == [m_constant]'0B'}1: ec3: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))} != ec0: {(_Bool)0 == [m_constant]'0'}}}created EN: 68
     point: callstring: [] before (SN: 9 stmt: 0):  _8 = t_13(D)->uu.newstr;
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(_Bool)0 == [m_constant]'0'}, ec1: {(void *)0B == [m_constant]'0B'}, ec2: {INIT_VAL(t_13(D))}, ec3: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}constraints:{0: ec2: {INIT_VAL(t_13(D))} != ec1: {(void *)0B == [m_constant]'0B'}1: ec3: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))} != ec0: {(_Bool)0 == [m_constant]'0'}}}}}
    exiting: get_or_create_node
    creating edge EN: 66 -> EN: 68
   exiting: process_node
   next to process: EN: 68
   peek worklist: EN: 67
   entering: process_node: EN: 68
    point: callstring: [] before (SN: 9 stmt: 0):  _8 = t_13(D)->uu.newstr;, state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(_Bool)0 == [m_constant]'0'}, ec1: {(void *)0B == [m_constant]'0B'}, ec2: {INIT_VAL(t_13(D))}, ec3: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}constraints:{0: ec2: {INIT_VAL(t_13(D))} != ec1: {(void *)0B == [m_constant]'0B'}1: ec3: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))} != ec0: {(_Bool)0 == [m_constant]'0'}}}}}
    entering: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
     _8 = t_13(D)->uu.newstr;
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     exiting: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
    exiting: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(_Bool)0 == [m_constant]'0'}, ec1: {(void *)0B == [m_constant]'0B'}, ec2: {INIT_VAL(t_13(D))}, ec3: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}constraints:{0: ec2: {INIT_VAL(t_13(D))} != ec1: {(void *)0B == [m_constant]'0B'}1: ec3: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))} != ec0: {(_Bool)0 == [m_constant]'0'}}}}}
     dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_8, value: INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(_Bool)0 == [m_constant]'0'}, ec1: {(void *)0B == [m_constant]'0B'}, ec2: {INIT_VAL(t_13(D))}, ec3: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}constraints:{0: ec2: {INIT_VAL(t_13(D))} != ec1: {(void *)0B == [m_constant]'0B'}1: ec3: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))} != ec0: {(_Bool)0 == [m_constant]'0'}}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
     dest_state maybe reachable svalues:
      0x3aca2a0: initial_svalue('char *', field_region(field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), 'union out_or_counting_u', 'uu'), 'char *', 'newstr'))
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    entering: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
     _9 = _8;
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     exiting: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
    exiting: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_8, value: INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(_Bool)0 == [m_constant]'0'}, ec1: {(void *)0B == [m_constant]'0B'}, ec2: {INIT_VAL(t_13(D))}, ec3: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}constraints:{0: ec2: {INIT_VAL(t_13(D))} != ec1: {(void *)0B == [m_constant]'0B'}1: ec3: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))} != ec0: {(_Bool)0 == [m_constant]'0'}}}}}
     dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_8, value: INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)}, region: {_9, value: INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(_Bool)0 == [m_constant]'0'}, ec1: {(void *)0B == [m_constant]'0B'}, ec2: {INIT_VAL(t_13(D))}, ec3: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}constraints:{0: ec2: {INIT_VAL(t_13(D))} != ec1: {(void *)0B == [m_constant]'0B'}1: ec3: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))} != ec0: {(_Bool)0 == [m_constant]'0'}}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
      0x3aca2a0: initial_svalue('char *', field_region(field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), 'union out_or_counting_u', 'uu'), 'char *', 'newstr'))
     dest_state maybe reachable svalues:
      0x3aca2a0: initial_svalue('char *', field_region(field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), 'union out_or_counting_u', 'uu'), 'char *', 'newstr'))
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     num_ssas_purged: 1
     num_decl_purged: 0
     entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
      src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_8, value: INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)}, region: {_9, value: INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(_Bool)0 == [m_constant]'0'}, ec1: {(void *)0B == [m_constant]'0B'}, ec2: {INIT_VAL(t_13(D))}, ec3: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}constraints:{0: ec2: {INIT_VAL(t_13(D))} != ec1: {(void *)0B == [m_constant]'0B'}1: ec3: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))} != ec0: {(_Bool)0 == [m_constant]'0'}}}}}
      dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_9, value: INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(_Bool)0 == [m_constant]'0'}, ec1: {(void *)0B == [m_constant]'0B'}, ec2: {INIT_VAL(t_13(D))}, ec3: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}constraints:{0: ec2: {INIT_VAL(t_13(D))} != ec1: {(void *)0B == [m_constant]'0B'}1: ec3: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))} != ec0: {(_Bool)0 == [m_constant]'0'}}}}}
      uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
      src_state known reachable svalues:
       0x3aca2a0: initial_svalue('char *', field_region(field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), 'union out_or_counting_u', 'uu'), 'char *', 'newstr'))
      dest_state maybe reachable svalues:
       0x3aca2a0: initial_svalue('char *', field_region(field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), 'union out_or_counting_u', 'uu'), 'char *', 'newstr'))
     exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    entering: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
     _10 = _9 + 1;
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     exiting: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
    exiting: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_9, value: INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(_Bool)0 == [m_constant]'0'}, ec1: {(void *)0B == [m_constant]'0B'}, ec2: {INIT_VAL(t_13(D))}, ec3: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}constraints:{0: ec2: {INIT_VAL(t_13(D))} != ec1: {(void *)0B == [m_constant]'0B'}1: ec3: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))} != ec0: {(_Bool)0 == [m_constant]'0'}}}}}
     dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_9, value: INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)}, region: {_10, value: (INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)+(sizetype)1)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(_Bool)0 == [m_constant]'0'}, ec1: {(void *)0B == [m_constant]'0B'}, ec2: {INIT_VAL(t_13(D))}, ec3: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}constraints:{0: ec2: {INIT_VAL(t_13(D))} != ec1: {(void *)0B == [m_constant]'0B'}1: ec3: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))} != ec0: {(_Bool)0 == [m_constant]'0'}}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
      0x3aca2a0: initial_svalue('char *', field_region(field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), 'union out_or_counting_u', 'uu'), 'char *', 'newstr'))
     dest_state maybe reachable svalues:
      0x3ae28f0: constant_svalue('sizetype', 1)
      0x3aca2a0: initial_svalue('char *', field_region(field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), 'union out_or_counting_u', 'uu'), 'char *', 'newstr'))
      0x3ad6a20: binop_svalue (pointer_plus_expr, initial_svalue('char *', field_region(field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), 'union out_or_counting_u', 'uu'), 'char *', 'newstr')), constant_svalue('sizetype', 1))
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    entering: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
     t_13(D)->uu.newstr = _10;
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     exiting: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
    exiting: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)}}clusters within frame: 'ss_out'@1 {, region: {_9, value: INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)}, region: {_10, value: (INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)+(sizetype)1)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(_Bool)0 == [m_constant]'0'}, ec1: {(void *)0B == [m_constant]'0B'}, ec2: {INIT_VAL(t_13(D))}, ec3: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}constraints:{0: ec2: {INIT_VAL(t_13(D))} != ec1: {(void *)0B == [m_constant]'0B'}1: ec3: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))} != ec0: {(_Bool)0 == [m_constant]'0'}}}}}
     dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)binding key: {bytes 0-7}, value: {(INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)+(sizetype)1)}}}clusters within frame: 'ss_out'@1 {, region: {_9, value: INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)}, region: {_10, value: (INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)+(sizetype)1)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(_Bool)0 == [m_constant]'0'}, ec1: {(void *)0B == [m_constant]'0B'}, ec2: {INIT_VAL(t_13(D))}, ec3: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}constraints:{0: ec2: {INIT_VAL(t_13(D))} != ec1: {(void *)0B == [m_constant]'0B'}1: ec3: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))} != ec0: {(_Bool)0 == [m_constant]'0'}}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
      0x3ae28f0: constant_svalue('sizetype', 1)
      0x3aca2a0: initial_svalue('char *', field_region(field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), 'union out_or_counting_u', 'uu'), 'char *', 'newstr'))
      0x3ad6a20: binop_svalue (pointer_plus_expr, initial_svalue('char *', field_region(field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), 'union out_or_counting_u', 'uu'), 'char *', 'newstr')), constant_svalue('sizetype', 1))
     dest_state maybe reachable svalues:
      0x3ae28f0: constant_svalue('sizetype', 1)
      0x3aca2a0: initial_svalue('char *', field_region(field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), 'union out_or_counting_u', 'uu'), 'char *', 'newstr'))
      0x3ad6a20: binop_svalue (pointer_plus_expr, initial_svalue('char *', field_region(field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), 'union out_or_counting_u', 'uu'), 'char *', 'newstr')), constant_svalue('sizetype', 1))
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     num_ssas_purged: 1
     num_decl_purged: 0
     entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
      src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)binding key: {bytes 0-7}, value: {(INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)+(sizetype)1)}}}clusters within frame: 'ss_out'@1 {, region: {_9, value: INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)}, region: {_10, value: (INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)+(sizetype)1)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(_Bool)0 == [m_constant]'0'}, ec1: {(void *)0B == [m_constant]'0B'}, ec2: {INIT_VAL(t_13(D))}, ec3: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}constraints:{0: ec2: {INIT_VAL(t_13(D))} != ec1: {(void *)0B == [m_constant]'0B'}1: ec3: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))} != ec0: {(_Bool)0 == [m_constant]'0'}}}}}
      dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)binding key: {bytes 0-7}, value: {(INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)+(sizetype)1)}}}clusters within frame: 'ss_out'@1 {, region: {_9, value: INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(_Bool)0 == [m_constant]'0'}, ec1: {(void *)0B == [m_constant]'0B'}, ec2: {INIT_VAL(t_13(D))}, ec3: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}constraints:{0: ec2: {INIT_VAL(t_13(D))} != ec1: {(void *)0B == [m_constant]'0B'}1: ec3: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))} != ec0: {(_Bool)0 == [m_constant]'0'}}}}}
      uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
      src_state known reachable svalues:
       0x3ae28f0: constant_svalue('sizetype', 1)
       0x3aca2a0: initial_svalue('char *', field_region(field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), 'union out_or_counting_u', 'uu'), 'char *', 'newstr'))
       0x3ad6a20: binop_svalue (pointer_plus_expr, initial_svalue('char *', field_region(field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), 'union out_or_counting_u', 'uu'), 'char *', 'newstr')), constant_svalue('sizetype', 1))
      dest_state maybe reachable svalues:
       0x3ae28f0: constant_svalue('sizetype', 1)
       0x3aca2a0: initial_svalue('char *', field_region(field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), 'union out_or_counting_u', 'uu'), 'char *', 'newstr'))
       0x3ad6a20: binop_svalue (pointer_plus_expr, initial_svalue('char *', field_region(field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), 'union out_or_counting_u', 'uu'), 'char *', 'newstr')), constant_svalue('sizetype', 1))
     exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    entering: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
     *_9 = cc_17(D);
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
      possible aliasing of (*INIT_VAL(t_13(D))) when writing SVAL: INIT_VAL(cc_17(D)) to LHS_REG: (*INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr))
     exiting: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: get_state
     exiting: get_state
    exiting: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {base region: {(*INIT_VAL(t_13(D)))} has cluster: {(ESCAPED)binding key: {bytes 0-7}, value: {(INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)+(sizetype)1)}}}clusters within frame: 'ss_out'@1 {, region: {_9, value: INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(_Bool)0 == [m_constant]'0'}, ec1: {(void *)0B == [m_constant]'0B'}, ec2: {INIT_VAL(t_13(D))}, ec3: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}}constraints:{0: ec2: {INIT_VAL(t_13(D))} != ec1: {(void *)0B == [m_constant]'0B'}1: ec3: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))} != ec0: {(_Bool)0 == [m_constant]'0'}}}}}
     dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {region: {(*INIT_VAL(t_13(D))), value: UNKNOWN(struct ss_s) (ESCAPED)}, region: {(*INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)), value: INIT_VAL(cc_17(D))}}clusters within frame: 'ss_out'@1 {, region: {_9, value: INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(_Bool)0 == [m_constant]'0'}, ec1: {(void *)0B == [m_constant]'0B'}, ec2: {INIT_VAL(t_13(D))}, ec3: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))}, ec4: {INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)}}constraints:{0: ec2: {INIT_VAL(t_13(D))} != ec1: {(void *)0B == [m_constant]'0B'}1: ec3: {(bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))} != ec0: {(_Bool)0 == [m_constant]'0'}2: ec4: {INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)} != ec1: {(void *)0B == [m_constant]'0B'}}}}}
     uncertainty: {m_maybe_bound_svals: {(INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)+(sizetype)1)}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
      0x3ae28f0: constant_svalue('sizetype', 1)
      0x3aca2a0: initial_svalue('char *', field_region(field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), 'union out_or_counting_u', 'uu'), 'char *', 'newstr'))
      0x3ad6a20: binop_svalue (pointer_plus_expr, initial_svalue('char *', field_region(field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), 'union out_or_counting_u', 'uu'), 'char *', 'newstr')), constant_svalue('sizetype', 1))
     dest_state maybe reachable svalues:
      0x3ae28f0: constant_svalue('sizetype', 1)
      0x3ac9910: unknown_svalue(struct ss_s)
      0x3add8f0: initial_svalue('char', decl_region(frame_region('ss_out', index: 0, depth: 1), 'char', 'cc_17(D)'))
      0x3aca2a0: initial_svalue('char *', field_region(field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), 'union out_or_counting_u', 'uu'), 'char *', 'newstr'))
      0x3ad6a20: binop_svalue (pointer_plus_expr, initial_svalue('char *', field_region(field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), 'union out_or_counting_u', 'uu'), 'char *', 'newstr')), constant_svalue('sizetype', 1))
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    entering: get_or_create_node
     point: callstring: [] after SN: 9
     state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {region: {(*INIT_VAL(t_13(D))), value: UNKNOWN(struct ss_s) (ESCAPED)}, region: {(*INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)), value: INIT_VAL(cc_17(D))}}clusters within frame: 'ss_out'@1 {, region: {_9, value: INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)}, ec2: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)} != ec0: {(void *)0B == [m_constant]'0B'}1: ec2: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {region: {(*INIT_VAL(t_13(D))), value: UNKNOWN(struct ss_s) (ESCAPED)}, region: {(*INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)), value: INIT_VAL(cc_17(D))}}clusters within frame: 'ss_out'@1 {, region: {_9, value: INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)}, ec2: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)} != ec0: {(void *)0B == [m_constant]'0B'}1: ec2: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {region: {(*INIT_VAL(t_13(D))), value: UNKNOWN(struct ss_s) (ESCAPED)}, region: {(*INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)), value: INIT_VAL(cc_17(D))}}clusters within frame: 'ss_out'@1 {, region: {_9, value: INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)}, ec2: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)} != ec0: {(void *)0B == [m_constant]'0B'}1: ec2: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}created EN: 69
     point: callstring: [] after SN: 9
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {region: {(*INIT_VAL(t_13(D))), value: UNKNOWN(struct ss_s) (ESCAPED)}, region: {(*INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)), value: INIT_VAL(cc_17(D))}}clusters within frame: 'ss_out'@1 {, region: {_9, value: INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)}, ec2: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)} != ec0: {(void *)0B == [m_constant]'0B'}1: ec2: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
    exiting: get_or_create_node
    creating edge EN: 68 -> EN: 69
   exiting: process_node
   next to process: EN: 69
   peek worklist: EN: 67
   entering: process_node: EN: 69
    point: callstring: [] after SN: 9, state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {region: {(*INIT_VAL(t_13(D))), value: UNKNOWN(struct ss_s) (ESCAPED)}, region: {(*INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)), value: INIT_VAL(cc_17(D))}}clusters within frame: 'ss_out'@1 {, region: {_9, value: INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)}, ec2: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)} != ec0: {(void *)0B == [m_constant]'0B'}1: ec2: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
    considering SN: 9 -> SN: 10 ( (flags FALLTHRU))
    entering: on_edge
     entering: on_edge
     exiting: on_edge
     entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
      src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {region: {(*INIT_VAL(t_13(D))), value: UNKNOWN(struct ss_s) (ESCAPED)}, region: {(*INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)), value: INIT_VAL(cc_17(D))}}clusters within frame: 'ss_out'@1 {, region: {_9, value: INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)}, ec2: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)} != ec0: {(void *)0B == [m_constant]'0B'}1: ec2: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
      dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {region: {(*INIT_VAL(t_13(D))), value: UNKNOWN(struct ss_s) (ESCAPED)}, region: {(*INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)), value: INIT_VAL(cc_17(D))}}clusters within frame: 'ss_out'@1 {, region: {_9, value: INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)}, ec2: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)} != ec0: {(void *)0B == [m_constant]'0B'}1: ec2: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
      uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
      src_state known reachable svalues:
       0x3ac9910: unknown_svalue(struct ss_s)
       0x3add8f0: initial_svalue('char', decl_region(frame_region('ss_out', index: 0, depth: 1), 'char', 'cc_17(D)'))
       0x3aca2a0: initial_svalue('char *', field_region(field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), 'union out_or_counting_u', 'uu'), 'char *', 'newstr'))
      dest_state maybe reachable svalues:
       0x3ac9910: unknown_svalue(struct ss_s)
       0x3add8f0: initial_svalue('char', decl_region(frame_region('ss_out', index: 0, depth: 1), 'char', 'cc_17(D)'))
       0x3aca2a0: initial_svalue('char *', field_region(field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), 'union out_or_counting_u', 'uu'), 'char *', 'newstr'))
     exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    exiting: on_edge
    entering: get_or_create_node
     point: callstring: [] before SN: 10 (from SN: 9 (bb: 3)) .MEM_11 = PHI <.MEM_15(2), .MEM_18(3)>
     state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {region: {(*INIT_VAL(t_13(D))), value: UNKNOWN(struct ss_s) (ESCAPED)}, region: {(*INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)), value: INIT_VAL(cc_17(D))}}clusters within frame: 'ss_out'@1 {, region: {_9, value: INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)}, ec2: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)} != ec0: {(void *)0B == [m_constant]'0B'}1: ec2: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
      num_ssas_purged: 1
      num_decl_purged: 0
      entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
       src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {region: {(*INIT_VAL(t_13(D))), value: UNKNOWN(struct ss_s) (ESCAPED)}, region: {(*INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)), value: INIT_VAL(cc_17(D))}}clusters within frame: 'ss_out'@1 {, region: {_9, value: INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)}, ec2: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)} != ec0: {(void *)0B == [m_constant]'0B'}1: ec2: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
       dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {region: {(*INIT_VAL(t_13(D))), value: UNKNOWN(struct ss_s) (ESCAPED)}, region: {(*INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)), value: INIT_VAL(cc_17(D))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)}, ec2: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)} != ec0: {(void *)0B == [m_constant]'0B'}1: ec2: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
       uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
       src_state known reachable svalues:
        0x3ac9910: unknown_svalue(struct ss_s)
        0x3add8f0: initial_svalue('char', decl_region(frame_region('ss_out', index: 0, depth: 1), 'char', 'cc_17(D)'))
        0x3aca2a0: initial_svalue('char *', field_region(field_region(symbolic_region(root_region(), 'struct ss_s', initial_svalue('struct ss_s *', decl_region(frame_region('ss_out', index: 0, depth: 1), 'struct ss_s *', 't_13(D)'))), 'union out_or_counting_u', 'uu'), 'char *', 'newstr'))
       dest_state maybe reachable svalues:
        0x3ac9910: unknown_svalue(struct ss_s)
        0x3add8f0: initial_svalue('char', decl_region(frame_region('ss_out', index: 0, depth: 1), 'char', 'cc_17(D)'))
      exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {region: {(*INIT_VAL(t_13(D))), value: UNKNOWN(struct ss_s) (ESCAPED)}, region: {(*INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)), value: INIT_VAL(cc_17(D))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {region: {(*INIT_VAL(t_13(D))), value: UNKNOWN(struct ss_s) (ESCAPED)}, region: {(*INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)), value: INIT_VAL(cc_17(D))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}created EN: 70
     point: callstring: [] before SN: 10 (from SN: 9 (bb: 3)) .MEM_11 = PHI <.MEM_15(2), .MEM_18(3)>
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {region: {(*INIT_VAL(t_13(D))), value: UNKNOWN(struct ss_s) (ESCAPED)}, region: {(*INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)), value: INIT_VAL(cc_17(D))}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
    exiting: get_or_create_node
    creating edge EN: 69 -> EN: 70
   exiting: process_node
   next to process: EN: 67
   entering: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
    got run of 2 enodes for SN: 10
    using new merger state 0 for item 0 (EN: 67)
    reusing merger state 0 for item 1 (EN: 70)
    entering: get_or_create_node
     point: callstring: [] before (SN: 10 stmt: 0):  return;
     state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {region: {(*INIT_VAL(t_13(D))), value: UNKNOWN(struct ss_s) (ESCAPED)}, region: {(*INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)), value: UNKNOWN(char)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {region: {(*INIT_VAL(t_13(D))), value: UNKNOWN(struct ss_s) (ESCAPED)}, region: {(*INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)), value: UNKNOWN(char)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {region: {(*INIT_VAL(t_13(D))), value: UNKNOWN(struct ss_s) (ESCAPED)}, region: {(*INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)), value: UNKNOWN(char)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}created EN: 71
     point: callstring: [] before (SN: 10 stmt: 0):  return;
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {region: {(*INIT_VAL(t_13(D))), value: UNKNOWN(struct ss_s) (ESCAPED)}, region: {(*INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)), value: UNKNOWN(char)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
    exiting: get_or_create_node
    using EN: 71 for merger state 0
    creating edge EN: 67 -> EN: 71
    creating edge EN: 70 -> EN: 71
    merged 2 in-enodes into 1 out-enode(s) at SN: 10
   exiting: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
   next to process: EN: 71
   peek worklist: EN: 3
   entering: process_node: EN: 71
    point: callstring: [] before (SN: 10 stmt: 0):  return;, state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {region: {(*INIT_VAL(t_13(D))), value: UNKNOWN(struct ss_s) (ESCAPED)}, region: {(*INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)), value: UNKNOWN(char)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
    entering: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
     return;
    exiting: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {region: {(*INIT_VAL(t_13(D))), value: UNKNOWN(struct ss_s) (ESCAPED)}, region: {(*INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)), value: UNKNOWN(char)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {region: {(*INIT_VAL(t_13(D))), value: UNKNOWN(struct ss_s) (ESCAPED)}, region: {(*INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)), value: UNKNOWN(char)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
      0x3ae7ee0: unknown_svalue(char)
      0x3ac9910: unknown_svalue(struct ss_s)
     dest_state maybe reachable svalues:
      0x3ae7ee0: unknown_svalue(char)
      0x3ac9910: unknown_svalue(struct ss_s)
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    entering: get_or_create_node
     point: callstring: [] after SN: 10
     state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {region: {(*INIT_VAL(t_13(D))), value: UNKNOWN(struct ss_s) (ESCAPED)}, region: {(*INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)), value: UNKNOWN(char)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {region: {(*INIT_VAL(t_13(D))), value: UNKNOWN(struct ss_s) (ESCAPED)}, region: {(*INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)), value: UNKNOWN(char)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {region: {(*INIT_VAL(t_13(D))), value: UNKNOWN(struct ss_s) (ESCAPED)}, region: {(*INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)), value: UNKNOWN(char)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}created EN: 72
     point: callstring: [] after SN: 10
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {region: {(*INIT_VAL(t_13(D))), value: UNKNOWN(struct ss_s) (ESCAPED)}, region: {(*INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)), value: UNKNOWN(char)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
    exiting: get_or_create_node
    creating edge EN: 71 -> EN: 72
   exiting: process_node
   next to process: EN: 72
   peek worklist: EN: 3
   entering: process_node: EN: 72
    point: callstring: [] after SN: 10, state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {region: {(*INIT_VAL(t_13(D))), value: UNKNOWN(struct ss_s) (ESCAPED)}, region: {(*INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)), value: UNKNOWN(char)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
    considering SN: 10 -> SN: 11 ()
    entering: on_edge
     entering: on_edge
     exiting: on_edge
     entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
      src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {region: {(*INIT_VAL(t_13(D))), value: UNKNOWN(struct ss_s) (ESCAPED)}, region: {(*INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)), value: UNKNOWN(char)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
      dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {region: {(*INIT_VAL(t_13(D))), value: UNKNOWN(struct ss_s) (ESCAPED)}, region: {(*INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)), value: UNKNOWN(char)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
      uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
      src_state known reachable svalues:
       0x3ae7ee0: unknown_svalue(char)
       0x3ac9910: unknown_svalue(struct ss_s)
      dest_state maybe reachable svalues:
       0x3ae7ee0: unknown_svalue(char)
       0x3ac9910: unknown_svalue(struct ss_s)
     exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    exiting: on_edge
    entering: get_or_create_node
     point: callstring: [] before SN: 11 (from SN: 10 (bb: 4)) 
     state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {region: {(*INIT_VAL(t_13(D))), value: UNKNOWN(struct ss_s) (ESCAPED)}, region: {(*INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)), value: UNKNOWN(char)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {region: {(*INIT_VAL(t_13(D))), value: UNKNOWN(struct ss_s) (ESCAPED)}, region: {(*INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)), value: UNKNOWN(char)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {region: {(*INIT_VAL(t_13(D))), value: UNKNOWN(struct ss_s) (ESCAPED)}, region: {(*INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)), value: UNKNOWN(char)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}created EN: 73
     point: callstring: [] before SN: 11 (from SN: 10 (bb: 4)) 
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {region: {(*INIT_VAL(t_13(D))), value: UNKNOWN(struct ss_s) (ESCAPED)}, region: {(*INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)), value: UNKNOWN(char)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
    exiting: get_or_create_node
    creating edge EN: 72 -> EN: 73
   exiting: process_node
   next to process: EN: 73
   entering: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
   exiting: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
   peek worklist: EN: 3
   entering: process_node: EN: 73
    point: callstring: [] before SN: 11 (from SN: 10 (bb: 4)) , state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {region: {(*INIT_VAL(t_13(D))), value: UNKNOWN(struct ss_s) (ESCAPED)}, region: {(*INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)), value: UNKNOWN(char)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {region: {(*INIT_VAL(t_13(D))), value: UNKNOWN(struct ss_s) (ESCAPED)}, region: {(*INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)), value: UNKNOWN(char)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {region: {(*INIT_VAL(t_13(D))), value: UNKNOWN(struct ss_s) (ESCAPED)}, region: {(*INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)), value: UNKNOWN(char)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
      0x3ae7ee0: unknown_svalue(char)
      0x3ac9910: unknown_svalue(struct ss_s)
     dest_state maybe reachable svalues:
      0x3ae7ee0: unknown_svalue(char)
      0x3ac9910: unknown_svalue(struct ss_s)
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: get_or_create_node
     point: callstring: [] after SN: 11
     state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {region: {(*INIT_VAL(t_13(D))), value: UNKNOWN(struct ss_s) (ESCAPED)}, region: {(*INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)), value: UNKNOWN(char)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {region: {(*INIT_VAL(t_13(D))), value: UNKNOWN(struct ss_s) (ESCAPED)}, region: {(*INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)), value: UNKNOWN(char)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
     stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {region: {(*INIT_VAL(t_13(D))), value: UNKNOWN(struct ss_s) (ESCAPED)}, region: {(*INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)), value: UNKNOWN(char)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}created EN: 74
     point: callstring: [] after SN: 11
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {region: {(*INIT_VAL(t_13(D))), value: UNKNOWN(struct ss_s) (ESCAPED)}, region: {(*INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)), value: UNKNOWN(char)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
    exiting: get_or_create_node
    creating edge EN: 73 -> EN: 74
   exiting: process_node
   next to process: EN: 74
   peek worklist: EN: 3
   entering: process_node: EN: 74
    point: callstring: [] after SN: 11, state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {region: {(*INIT_VAL(t_13(D))), value: UNKNOWN(struct ss_s) (ESCAPED)}, region: {(*INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)), value: UNKNOWN(char)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
    entering: detect_leaks: EN: 74
     entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
      src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_out'@1}, {clusters within root region {region: {(*INIT_VAL(t_13(D))), value: UNKNOWN(struct ss_s) (ESCAPED)}, region: {(*INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)), value: UNKNOWN(char)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
      dest_state: {rmodel: {stack depth: 0 {}, {clusters within root region {region: {(*INIT_VAL(t_13(D))), value: UNKNOWN(struct ss_s) (ESCAPED)}, region: {(*INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)), value: UNKNOWN(char)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {ec0: {(void *)0B == [m_constant]'0B'}, ec1: {INIT_VAL(t_13(D))}}constraints:{0: ec1: {INIT_VAL(t_13(D))} != ec0: {(void *)0B == [m_constant]'0B'}}}}}
      uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
      src_state known reachable svalues:
       0x3ae7ee0: unknown_svalue(char)
       0x3ac9910: unknown_svalue(struct ss_s)
      dest_state maybe reachable svalues:
       0x3ae7ee0: unknown_svalue(char)
       0x3ac9910: unknown_svalue(struct ss_s)
     exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    exiting: detect_leaks
    considering SN: 11 -> SN: 3 (return)
    entering: on_edge
     entering: on_edge
      rejecting return edge: empty call string
     exiting: on_edge
    exiting: on_edge
    skipping impossible edge to SN: 3
   exiting: process_node
   next to process: EN: 3
   entering: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
   exiting: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
   entering: process_node: EN: 3
    point: callstring: [] before SN: 12 (NULL from-edge) , state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    entering: get_or_create_node
     point: callstring: [] after SN: 12
     state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}created EN: 75
     point: callstring: [] after SN: 12
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    exiting: get_or_create_node
    creating edge EN: 3 -> EN: 75
   exiting: process_node
   next to process: EN: 75
   entering: process_node: EN: 75
    point: callstring: [] after SN: 12, state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    considering SN: 12 -> SN: 13 ( (flags FALLTHRU))
    entering: on_edge
     entering: on_edge
     exiting: on_edge
     entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
      src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
      dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
      uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
      src_state known reachable svalues:
      dest_state maybe reachable svalues:
     exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    exiting: on_edge
    entering: get_or_create_node
     point: callstring: [] before SN: 13 (from SN: 12 (bb: 0)) 
     state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}created EN: 76
     point: callstring: [] before SN: 13 (from SN: 12 (bb: 0)) 
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    exiting: get_or_create_node
    creating edge EN: 75 -> EN: 76
   exiting: process_node
   next to process: EN: 76
   entering: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
   exiting: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
   entering: process_node: EN: 76
    point: callstring: [] before SN: 13 (from SN: 12 (bb: 0)) , state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
     dest_state maybe reachable svalues:
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: get_or_create_node
     point: callstring: [] before (SN: 13 stmt: 0):  rr = {};
     state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}created EN: 77
     point: callstring: [] before (SN: 13 stmt: 0):  rr = {};
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    exiting: get_or_create_node
    creating edge EN: 76 -> EN: 77
   exiting: process_node
   next to process: EN: 77
   entering: process_node: EN: 77
    point: callstring: [] before (SN: 13 stmt: 0):  rr = {};, state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    entering: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
     rr = {};
    exiting: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {clusters within frame: 'ss_init'@1 {region: {rr, value: CAST(struct ss_s, (char)0)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
     dest_state maybe reachable svalues:
      0x3a9a8c0: constant_svalue('char', 0)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    entering: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
     rr.counting = 1;
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     exiting: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
    exiting: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {clusters within frame: 'ss_init'@1 {region: {rr, value: CAST(struct ss_s, (char)0)}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {clusters within frame: 'ss_init'@1 {base region: {rr} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
      0x3a9a8c0: constant_svalue('char', 0)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
     dest_state maybe reachable svalues:
      0x3a9a8c0: constant_svalue('char', 0)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    entering: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
     D.2757 = rr;
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     exiting: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
    exiting: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {clusters within frame: 'ss_init'@1 {base region: {rr} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {clusters within frame: 'ss_init'@1 {base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, base region: {rr} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
      0x3a9a8c0: constant_svalue('char', 0)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
     dest_state maybe reachable svalues:
      0x3a9a8c0: constant_svalue('char', 0)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     num_ssas_purged: 0
     num_decl_purged: 1
     entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
      src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {clusters within frame: 'ss_init'@1 {base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, base region: {rr} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
      dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {clusters within frame: 'ss_init'@1 {base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, base region: {rr} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
      uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
      src_state known reachable svalues:
       0x3a9a8c0: constant_svalue('char', 0)
       0x3a9c710: constant_svalue('_Bool', 1)
       0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
      dest_state maybe reachable svalues:
       0x3a9a8c0: constant_svalue('char', 0)
       0x3a9c710: constant_svalue('_Bool', 1)
       0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
     exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    entering: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
     rr ={v} {CLOBBER(eol)};
    exiting: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {clusters within frame: 'ss_init'@1 {base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, base region: {rr} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {clusters within frame: 'ss_init'@1 {base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
      0x3a9a8c0: constant_svalue('char', 0)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
     dest_state maybe reachable svalues:
      0x3a9a8c0: constant_svalue('char', 0)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    entering: get_or_create_node
     point: callstring: [] after SN: 13
     state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {clusters within frame: 'ss_init'@1 {base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {clusters within frame: 'ss_init'@1 {base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {clusters within frame: 'ss_init'@1 {base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}created EN: 78
     point: callstring: [] after SN: 13
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {clusters within frame: 'ss_init'@1 {base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    exiting: get_or_create_node
    creating edge EN: 77 -> EN: 78
   exiting: process_node
   next to process: EN: 78
   entering: process_node: EN: 78
    point: callstring: [] after SN: 13, state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {clusters within frame: 'ss_init'@1 {base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    considering SN: 13 -> SN: 14 ( (flags FALLTHRU))
    entering: on_edge
     entering: on_edge
     exiting: on_edge
     entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
      src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {clusters within frame: 'ss_init'@1 {base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
      dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {clusters within frame: 'ss_init'@1 {base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
      uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
      src_state known reachable svalues:
       0x3a9a8c0: constant_svalue('char', 0)
       0x3a9c710: constant_svalue('_Bool', 1)
       0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
      dest_state maybe reachable svalues:
       0x3a9a8c0: constant_svalue('char', 0)
       0x3a9c710: constant_svalue('_Bool', 1)
       0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
     exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    exiting: on_edge
    entering: get_or_create_node
     point: callstring: [] before SN: 14 (from SN: 13 (bb: 2)) 
     state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {clusters within frame: 'ss_init'@1 {base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {clusters within frame: 'ss_init'@1 {base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {clusters within frame: 'ss_init'@1 {base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}created EN: 79
     point: callstring: [] before SN: 14 (from SN: 13 (bb: 2)) 
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {clusters within frame: 'ss_init'@1 {base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    exiting: get_or_create_node
    creating edge EN: 78 -> EN: 79
   exiting: process_node
   next to process: EN: 79
   entering: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
   exiting: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
   entering: process_node: EN: 79
    point: callstring: [] before SN: 14 (from SN: 13 (bb: 2)) , state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {clusters within frame: 'ss_init'@1 {base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {clusters within frame: 'ss_init'@1 {base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {clusters within frame: 'ss_init'@1 {base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
      0x3a9a8c0: constant_svalue('char', 0)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
     dest_state maybe reachable svalues:
      0x3a9a8c0: constant_svalue('char', 0)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: get_or_create_node
     point: callstring: [] before (SN: 14 stmt: 0):  <L1>:
     state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {clusters within frame: 'ss_init'@1 {base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {clusters within frame: 'ss_init'@1 {base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {clusters within frame: 'ss_init'@1 {base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}created EN: 80
     point: callstring: [] before (SN: 14 stmt: 0):  <L1>:
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {clusters within frame: 'ss_init'@1 {base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    exiting: get_or_create_node
    creating edge EN: 79 -> EN: 80
   exiting: process_node
   next to process: EN: 80
   entering: process_node: EN: 80
    point: callstring: [] before (SN: 14 stmt: 0):  <L1>:, state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {clusters within frame: 'ss_init'@1 {base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    entering: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
     <L1>:
    exiting: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {clusters within frame: 'ss_init'@1 {base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {clusters within frame: 'ss_init'@1 {base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
      0x3a9a8c0: constant_svalue('char', 0)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
     dest_state maybe reachable svalues:
      0x3a9a8c0: constant_svalue('char', 0)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    entering: get_or_create_node
     point: callstring: [] before (SN: 14 stmt: 1):  return D.2757;
     state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {clusters within frame: 'ss_init'@1 {base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {clusters within frame: 'ss_init'@1 {base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {clusters within frame: 'ss_init'@1 {base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}created EN: 81
     point: callstring: [] before (SN: 14 stmt: 1):  return D.2757;
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {clusters within frame: 'ss_init'@1 {base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    exiting: get_or_create_node
    creating edge EN: 80 -> EN: 81
   exiting: process_node
   next to process: EN: 81
   entering: process_node: EN: 81
    point: callstring: [] before (SN: 14 stmt: 1):  return D.2757;, state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {clusters within frame: 'ss_init'@1 {base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    entering: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
     return D.2757;
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
     exiting: void ana::store::set_value(ana::store_manager*, const ana::region*, const ana::svalue*, ana::uncertainty_t*)
    exiting: ana::exploded_node::on_stmt_flags ana::exploded_node::on_stmt(ana::exploded_graph&, const ana::supernode*, const gimple*, ana::program_state*, ana::uncertainty_t*, ana::path_context*)
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {clusters within frame: 'ss_init'@1 {base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {clusters within frame: 'ss_init'@1 {base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
      0x3a9a8c0: constant_svalue('char', 0)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
     dest_state maybe reachable svalues:
      0x3a9a8c0: constant_svalue('char', 0)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
    entering: get_or_create_node
     point: callstring: [] after SN: 14
     state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {clusters within frame: 'ss_init'@1 {base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {clusters within frame: 'ss_init'@1 {base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {clusters within frame: 'ss_init'@1 {base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}created EN: 82
     point: callstring: [] after SN: 14
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {clusters within frame: 'ss_init'@1 {base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    exiting: get_or_create_node
    creating edge EN: 81 -> EN: 82
   exiting: process_node
   next to process: EN: 82
   entering: process_node: EN: 82
    point: callstring: [] after SN: 14, state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {clusters within frame: 'ss_init'@1 {base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    considering SN: 14 -> SN: 15 ()
    entering: on_edge
     entering: on_edge
     exiting: on_edge
     entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
      src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {clusters within frame: 'ss_init'@1 {base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
      dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {clusters within frame: 'ss_init'@1 {base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
      uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
      src_state known reachable svalues:
       0x3a9a8c0: constant_svalue('char', 0)
       0x3a9c710: constant_svalue('_Bool', 1)
       0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
      dest_state maybe reachable svalues:
       0x3a9a8c0: constant_svalue('char', 0)
       0x3a9c710: constant_svalue('_Bool', 1)
       0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
     exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    exiting: on_edge
    entering: get_or_create_node
     point: callstring: [] before SN: 15 (from SN: 14 (bb: 3)) 
     state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {clusters within frame: 'ss_init'@1 {base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
      num_ssas_purged: 0
      num_decl_purged: 1
      entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
       src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {clusters within frame: 'ss_init'@1 {base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
       dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {clusters within frame: 'ss_init'@1 {base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
       uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
       src_state known reachable svalues:
        0x3a9a8c0: constant_svalue('char', 0)
        0x3a9c710: constant_svalue('_Bool', 1)
        0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
       dest_state maybe reachable svalues:
        0x3a9a8c0: constant_svalue('char', 0)
        0x3a9c710: constant_svalue('_Bool', 1)
        0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
      exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {clusters within frame: 'ss_init'@1 {base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {clusters within frame: 'ss_init'@1 {base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}created EN: 83
     point: callstring: [] before SN: 15 (from SN: 14 (bb: 3)) 
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {clusters within frame: 'ss_init'@1 {base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    exiting: get_or_create_node
    creating edge EN: 82 -> EN: 83
   exiting: process_node
   next to process: EN: 83
   entering: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
   exiting: bool ana::exploded_graph::maybe_process_run_of_before_supernode_enodes(ana::exploded_node*)
   entering: process_node: EN: 83
    point: callstring: [] before SN: 15 (from SN: 14 (bb: 3)) , state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {clusters within frame: 'ss_init'@1 {base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {clusters within frame: 'ss_init'@1 {base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {clusters within frame: 'ss_init'@1 {base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
     src_state known reachable svalues:
      0x3a9a8c0: constant_svalue('char', 0)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
     dest_state maybe reachable svalues:
      0x3a9a8c0: constant_svalue('char', 0)
      0x3a9c710: constant_svalue('_Bool', 1)
      0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
    exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    entering: get_or_create_node
     point: callstring: [] after SN: 15
     state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {clusters within frame: 'ss_init'@1 {base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     entering: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
      num_ssas_purged: 0
      num_decl_purged: 1
      entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
       src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {clusters within frame: 'ss_init'@1 {base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
       dest_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {clusters within frame: 'ss_init'@1 {base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
       uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
       src_state known reachable svalues:
        0x3a9a8c0: constant_svalue('char', 0)
        0x3a9c710: constant_svalue('_Bool', 1)
        0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
       dest_state maybe reachable svalues:
        0x3a9a8c0: constant_svalue('char', 0)
        0x3a9c710: constant_svalue('_Bool', 1)
        0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
      exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
     exiting: ana::program_state ana::program_state::prune_for_point(ana::exploded_graph&, const ana::program_point&, ana::exploded_node*, ana::uncertainty_t*) const
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {clusters within frame: 'ss_init'@1 {base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
     stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {clusters within frame: 'ss_init'@1 {base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}created EN: 84
     point: callstring: [] after SN: 15
     pruned_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {clusters within frame: 'ss_init'@1 {base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    exiting: get_or_create_node
    creating edge EN: 83 -> EN: 84
   exiting: process_node
   next to process: EN: 84
   entering: process_node: EN: 84
    point: callstring: [] after SN: 15, state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {clusters within frame: 'ss_init'@1 {base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
    entering: detect_leaks: EN: 84
     entering: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     exiting: void ana::region_model::check_region_for_taint(const ana::region*, ana::access_direction, ana::region_model_context*) const
     entering: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
      src_state: {rmodel: {stack depth: 1 {frame (index 0): frame: 'ss_init'@1}, {clusters within frame: 'ss_init'@1 {base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}, base region: {<anonymous>} has cluster: {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}}}m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
      dest_state: {rmodel: {stack depth: 0 {}, {m_called_unknown_fn: FALSE}constraint_manager: {equiv classes: {}constraints:{}}}}
      extra_sval: COMPOUND('struct ss_s', {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}})
      uncertainty: {m_maybe_bound_svals: {}, m_mutable_at_unknown_call_svals: {}}
      src_state known reachable svalues:
       0x3a9a8c0: constant_svalue('char', 0)
       0x3a9c710: constant_svalue('_Bool', 1)
       0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
      dest_state maybe reachable svalues:
       0x3a9a8c0: constant_svalue('char', 0)
       0x3a9c710: constant_svalue('_Bool', 1)
       0x3aa4d90: unaryop_svalue (nop_expr, constant_svalue('char', 0))
       0x3aa5200: compound_svalue ('struct ss_s', {binding key: {bytes 0-7}, value: {unaryop_svalue (nop_expr, constant_svalue('char', 0))}, binding key: {start: 64, size: 1, next: 65}, value: {constant_svalue('_Bool', 1)}, binding key: {start: 65, size: 63, next: 128}, value: {unaryop_svalue (nop_expr, constant_svalue('char', 0))}})
     exiting: static void ana::program_state::detect_leaks(const ana::program_state&, const ana::program_state&, const ana::svalue*, const ana::extrinsic_state&, ana::region_model_context*)
    exiting: detect_leaks
    considering SN: 15 -> SN: 2 (return)
    entering: on_edge
     entering: on_edge
      rejecting return edge: empty call string
     exiting: on_edge
    exiting: on_edge
    skipping impossible edge to SN: 2
   exiting: process_node
  exiting: void ana::exploded_graph::process_worklist()
  entering: void ana::diagnostic_manager::emit_saved_diagnostics(const ana::exploded_graph&)
   # saved diagnostics: 0
   # disabled diagnostics: 0
  exiting: void ana::diagnostic_manager::emit_saved_diagnostics(const ana::exploded_graph&)
  entering: void ana::exploded_graph::log_stats() const
   entering: void ana::region_model_manager::log_stats(ana::logger*, bool) const
    call string consolidation
    []
      [..., (SN: 11 -> SN: 3 in main)]
        [..., ..., (SN: 18 -> SN: 8 in ss_out)]
      [..., (SN: 15 -> SN: 2 in main)]
      [..., (SN: 18 -> SN: 8 in ss_out)]
    svalue consolidation
      # constant_svalue: 20
        (sizetype)1
        (sizetype)4
        (sizetype)16
        (bitsizetype)8
        (bitsizetype)32
        (bitsizetype)64
        (char)0
        (char)97
        (int)0
        (int)1
        (int)97
        (long unsigned int)1
        (long unsigned int)4
        (long unsigned int)8
        (long unsigned int)16
        (_Bool)0
        (_Bool)1
        (void *)0B
        (char *)0B
        (struct ss_s *)0B
      # unknown_svalue: 5
        UNKNOWN(char)
        UNKNOWN(_Bool)
        UNKNOWN(char *)
        UNKNOWN(struct ss_s)
        UNKNOWN(union out_or_counting_u)
      # poisoned_svalue: 2
        POISONED('', uninit)
        POISONED('struct ss_s', uninit)
      # setjmp_svalue: 0
      # initial_svalue: 6
        INIT_VAL(cc_17(D))
        INIT_VAL((*INIT_VAL(t_13(D))).counting)
        INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)
        INIT_VAL((*INIT_VAL(t_13(D))))
        INIT_VAL((*INIT_VAL(t_13(D))).uu)
        INIT_VAL(t_13(D))
      # region_svalue: 5
        &ss
        &'__analyzer_describe'
        &'__analyzer_eval'
        &'ss_init'
        &'ss_out'
      # unaryop_svalue: 4
        CAST(int, INIT_VAL((*INIT_VAL(t_13(D))).counting))
        CAST(int, (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting)))
        (bit_not_exprINIT_VAL((*INIT_VAL(t_13(D))).counting))
        CAST(struct ss_s, (char)0)
      # binop_svalue: 1
        (INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr)+(sizetype)1)
      # sub_svalue: 0
      # repeated_svalue: 0
      # bits_within_svalue: 0
      # unmergeable_svalue: 0
      # widening_svalue: 0
      # compound_svalue: 1
        COMPOUND('struct ss_s', {binding key: {bytes 0-7}, value: {CAST(struct ss_s, (char)0)}, binding key: {start: 64, size: 1, next: 65}, value: {(_Bool)1}, binding key: {start: 65, size: 63, next: 128}, value: {CAST(struct ss_s, (char)0)}})
      # conjured_svalue: 1
        CONJURED(ss = ss_init ();, ss)
      # asm_output_svalue: 0
      # const_fn_result_svalue: 0
    max accepted svalue num_nodes: 14
    max accepted svalue max_depth: 11
    region consolidation
      next region id: 58
      # function_region: 4
        'ss_init'
        '__analyzer_describe'
        'ss_out'
        '__analyzer_eval'
      # label_region: 0
      # decl_region for globals: 0
      # field_region: 6
        rr.counting
        rr.counting
        ss.counting
        (*INIT_VAL(t_13(D))).counting
        (*INIT_VAL(t_13(D))).uu
        (*INIT_VAL(t_13(D))).uu.newstr
      # element_region: 0
      # offset_region: 0
      # sized_region: 0
      # cast_region: 0
      # frame_region: 7
        frame: 'main'@1 [with 5 region(s) for locals]
        frame: 'ss_init'@1 [with 3 region(s) for locals]
        frame: 'ss_out'@1 [with 12 region(s) for locals]
        frame: 'ss_init'@2 [with 3 region(s) for locals]
        frame: 'ss_out'@2 [with 9 region(s) for locals]
        frame: '__analyzer_eval'@3 [with 1 region(s) for locals]
        frame: '__analyzer_eval'@2 [with 1 region(s) for locals]
      # symbolic_region: 2
        (*INIT_VAL(t_13(D)))
        (*INIT_VAL((*INIT_VAL(t_13(D))).uu.newstr))
      # string_region: 0
      # bit_range_region: 0
      # var_arg_region: 0
      # managed dynamic regions: 0
    entering: void ana::store_manager::log_stats(ana::logger*, bool) const
       # concrete_binding: 8
         start: 0, size: 1, next: 1
         byte 0
         bytes 0-3
         bytes 0-7
         start: 0, size: 65, next: 65
         bytes 0-15
         start: 64, size: 1, next: 65
         start: 65, size: 63, next: 128
       # symbolic_binding: 4
         region: root region
         region: frame: 'main'@1
         region: frame: 'ss_out'@1
         region: frame: 'ss_out'@2
    exiting: void ana::store_manager::log_stats(ana::logger*, bool) const
    entering: void ana::bounded_ranges_manager::log_stats(ana::logger*, bool) const
       # ranges: 0
    exiting: void ana::bounded_ranges_manager::log_stats(ana::logger*, bool) const
   exiting: void ana::region_model_manager::log_stats(ana::logger*, bool) const
   m_sg.num_nodes (): 19
   m_nodes.length (): 85
   m_edges.length (): 85
   remaining enodes in worklist: 0
   global stats:
   m_num_nodes[PK_ORIGIN]: 1
   m_num_nodes[PK_BEFORE_SUPERNODE]: 32
   m_num_nodes[PK_BEFORE_STMT]: 21
   m_num_nodes[PK_AFTER_SUPERNODE]: 31
   m_node_reuse_count: 0
   m_node_reuse_after_merge_count: 0
   entering: main
    m_num_nodes[PK_BEFORE_SUPERNODE]: 6
    m_num_nodes[PK_BEFORE_STMT]: 6
    m_num_nodes[PK_AFTER_SUPERNODE]: 6
    m_node_reuse_count: 0
    m_node_reuse_after_merge_count: 0
   exiting: main
   entering: ss_out
    m_num_nodes[PK_BEFORE_SUPERNODE]: 12
    m_num_nodes[PK_BEFORE_STMT]: 7
    m_num_nodes[PK_AFTER_SUPERNODE]: 11
    m_node_reuse_count: 0
    m_node_reuse_after_merge_count: 0
   exiting: ss_out
   entering: ss_init
    m_num_nodes[PK_BEFORE_SUPERNODE]: 8
    m_num_nodes[PK_BEFORE_STMT]: 6
    m_num_nodes[PK_AFTER_SUPERNODE]: 8
    m_node_reuse_count: 0
    m_node_reuse_after_merge_count: 0
   exiting: ss_init
   entering: __analyzer_eval
    m_num_nodes[PK_BEFORE_SUPERNODE]: 6
    m_num_nodes[PK_BEFORE_STMT]: 2
    m_num_nodes[PK_AFTER_SUPERNODE]: 6
    m_node_reuse_count: 0
    m_node_reuse_after_merge_count: 0
   exiting: __analyzer_eval
  enodes per function:
main           : 18|##################            |
ss_out         : 30|##############################|
ss_init        : 22|######################        |
__analyzer_eval: 14|##############                |
per-function enodes per supernode/BB:
function: 'main'
sn 0 (bb 0): 2|##  |
sn 1 (bb 2): 3|### |
sn 2 (bb 2): 3|### |
sn 3 (bb 2): 4|####|
sn 4 (bb 3): 4|####|
sn 5 (bb 1): 2|##  |
function: 'ss_out'
sn 6 (bb 0) : 4|####   |
sn 7 (bb 2) : 6|###### |
sn 8 (bb 2) : 6|###### |
sn 9 (bb 3) : 3|###    |
sn 10 (bb 4): 7|#######|
sn 11 (bb 1): 4|####   |
function: 'ss_init'
sn 12 (bb 0): 4|####    |
sn 13 (bb 2): 6|######  |
sn 14 (bb 3): 8|########|
sn 15 (bb 1): 4|####    |
function: '__analyzer_eval'
sn 16 (bb 0): 4|####  |
sn 17 (bb 2): 6|######|
sn 18 (bb 1): 4|####  |
exiting: void ana::exploded_graph::log_stats() const
 exiting: void ana::impl_run_checkers(logger*)
exiting: void ana::run_checkers()
ana::logger::~logger()
